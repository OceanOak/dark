module Darklang =
  module Internal =
    module Test =
      type WTTest =
        { name: String
          lineNumber: Int64
          actual: LanguageTools.WrittenTypes.Expr
          expected: LanguageTools.WrittenTypes.Expr }

      type PTTest =
        { name: String
          lineNumber: Int64
          actual: LanguageTools.ProgramTypes.Expr
          expected: LanguageTools.ProgramTypes.Expr }

      let parseTest
        (pf: LanguageTools.WrittenTypes.ParsedFile)
        : Stdlib.Result.Result<WTTest, String> =
        let exprsToEval =
          match pf with
          | SourceFile s -> s.exprsToEval
          | _ -> []

        match exprsToEval with
        | [] -> Stdlib.Result.Result.Error "no exprs to eval"
        | [ e ] ->
          match e with
          | EInfix(r, _, actual, expected) ->
            (WTTest
              { name = "test"
                lineNumber = r.start.row
                actual = actual
                expected = expected })
            |> Stdlib.Result.Result.Ok

          | _ -> Stdlib.Result.Result.Error "expected x = y format"

      // CLEANUP: return result?
      let parseSingleTestFromFile (filename: String) (testSource: String) : PTTest =
        let wtTest =
          testSource
          |> LanguageTools.Parser.ParserTest.initialParse
          |> Test.parseTest
          |> Builtin.unwrap

        let lineNumber = wtTest.lineNumber
        let pm = LanguageTools.PackageManager.pm ()

        let actual =
          LanguageTools.WrittenTypesToProgramTypes.Expr.toPT
            LanguageTools.NameResolver.OnMissing.ThrowError
            pm
            ""
            []
            wtTest.actual

        let expected =
          LanguageTools.WrittenTypesToProgramTypes.Expr.toPT
            LanguageTools.NameResolver.OnMissing.ThrowError
            pm
            ""
            []
            wtTest.expected

        PTTest
          { name = "test"
            lineNumber = lineNumber
            actual = actual
            expected = expected }

      type WTModule =
        { name: List<String>
          types: List<LanguageTools.WrittenTypes.TypeReference.TypeReference>
          constants:
            List<LanguageTools.WrittenTypes.ConstantDeclaration.ConstantDeclaration>
          fns: List<LanguageTools.WrittenTypes.FnDeclaration.FnDeclaration>
          // dbs: List<LanguageTools.WrittenTypes.DB> // TODO
          tests: List<WTTest> }

      type PTModule =
        { name: List<String>
          types: List<LanguageTools.ProgramTypes.PackageType.PackageType>
          fns: List<LanguageTools.ProgramTypes.PackageFn.PackageFn>
          constants: List<LanguageTools.ProgramTypes.PackageConstant.PackageConstant>
          // dbs : List<LanguageTools.ProgramTypes.DB> // TODO
          tests: List<PTTest> }


      let toPT
        (owner: String)
        (onMissing: LanguageTools.NameResolver.OnMissing)
        (pm: LanguageTools.ProgramTypes.PackageManager.PackageManager)
        (m: WTModule)
        : PTModule =
        let types =
          m.types
          |> Stdlib.List.map (fun t ->
            LanguageTools.WrittenTypesToProgramTypes.TypeDeclaration.toPackageTypePT
              onMissing
              pm
              owner
              m.name
              t)

        let constants =
          m.constants
          |> Stdlib.List.map (fun c ->
            LanguageTools.WrittenTypesToProgramTypes.ConstantDeclaration.toPackageConstPT
              onMissing
              pm
              owner
              m.name
              c)

        let fns =
          m.fns
          |> Stdlib.List.map (fun f ->
            LanguageTools.WrittenTypesToProgramTypes.FunctionDeclaration.toPackageFnPT
              onMissing
              pm
              owner
              m.name
              f)

        let tests =
          m.tests
          |> Stdlib.List.map (fun t ->
            let currentModule = Stdlib.List.append m.name [ t.name ]

            PTTest
              { name = t.name
                lineNumber = t.lineNumber
                actual =
                  LanguageTools.WrittenTypesToProgramTypes.Expr.toPT
                    onMissing
                    pm
                    owner
                    currentModule
                    t.actual
                expected =
                  LanguageTools.WrittenTypesToProgramTypes.Expr.toPT
                    onMissing
                    pm
                    owner
                    currentModule
                    t.expected })

        PTModule
          { name = m.name
            types = types
            constants = constants
            fns = fns
            tests = tests }


      let parseModule
        (currentModule: List<String>)
        (m: LanguageTools.WrittenTypes.ModuleDeclaration.ModuleDeclaration)
        : List<WTModule> =
        let types =
          m.declarations
          |> Stdlib.List.filterMap (fun d ->
            match d with
            | Type t -> Stdlib.Option.Option.Some t
            | _ -> Stdlib.Option.Option.None)

        let constants =
          m.declarations
          |> Stdlib.List.filterMap (fun d ->
            match d with
            | Constant c -> Stdlib.Option.Option.Some c
            | _ -> Stdlib.Option.Option.None)

        let fns =
          m.declarations
          |> Stdlib.List.filterMap (fun d ->
            match d with
            | Function f -> Stdlib.Option.Option.Some f
            | _ -> Stdlib.Option.Option.None)

        let tests =
          m.declarations
          |> Stdlib.List.filterMap (fun decl ->
            match decl with
            | Expr e ->
              match e with
              | EInfix(r, _, actual, expected) ->
                let (_, name) = m.name

                Stdlib.Option.Option.Some(
                  WTTest
                    { name = name
                      lineNumber = r.start.row
                      actual = actual
                      expected = expected }
                )
              | _ -> Stdlib.Option.Option.None
            | _ -> Stdlib.Option.Option.None)

        let submodules =
          m.declarations
          |> Stdlib.List.filterMap (fun decl ->
            match decl with
            | SubModule m ->
              let (_, name) = m.name
              let names = Stdlib.List.append currentModule [ name ]
              Stdlib.Option.Option.Some(parseModule names m)
            | _ -> Stdlib.Option.Option.None)
          |> Stdlib.List.flatten

        Stdlib.List.append
          [ WTModule
              { name = currentModule
                types = types
                constants = constants
                fns = fns
                tests = tests } ]
          submodules



      let parseFile
        (parsedFile: LanguageTools.WrittenTypes.ParsedFile)
        (owner: String)
        : List<WTModule> =
        match parsedFile with
        | SourceFile source ->
          let modules =
            source.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Module m -> Stdlib.Option.Option.Some m
              | _ -> Stdlib.Option.Option.None)

          let parsedModule =
            modules
            |> Stdlib.List.map (fun m ->
              let (_, name) = m.name
              parseModule [ name ] m)
            |> Stdlib.List.flatten

          let rootTypes =
            source.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Type t -> Stdlib.Option.Option.Some t
              | _ -> Stdlib.Option.Option.None)

          let rootConstants =
            source.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Constant c -> Stdlib.Option.Option.Some c
              | _ -> Stdlib.Option.Option.None)

          let rootFns =
            source.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Function f -> Stdlib.Option.Option.Some f
              | _ -> Stdlib.Option.Option.None)

          let rootTests =
            source.exprsToEval
            |> Stdlib.List.filterMap (fun e ->
              match e with
              | EInfix(r, _, actual, expected) ->
                (WTTest
                  { name = "test"
                    lineNumber = r.start.row
                    actual = actual
                    expected = expected })
                |> Stdlib.Option.Option.Some
              | _ -> Stdlib.Option.Option.None)


          let rootModule =
            [ WTModule
                { name = []
                  types = rootTypes
                  constants = rootConstants
                  fns = rootFns
                  tests = rootTests } ]

          Stdlib.List.flatten [ rootModule; parsedModule ]

      let parseTestFile
        (owner: String)
        (pm: LanguageTools.ProgramTypes.PackageManager.PackageManager)
        (onMissing: LanguageTools.NameResolver.OnMissing)
        (filename: String)
        : List<PTModule> =
        let modulesWT =
          match Builtin.fileRead filename with
          | Ok content ->
            content
            |> Stdlib.String.fromBytesWithReplacement
            |> LanguageTools.Parser.ParserTest.initialParse
            |> parseFile owner
          | Error _ -> Stdlib.Result.Result.Error $"error reading file {filename}"

        let afterFirstPass =
          modulesWT |> Stdlib.List.map (fun m -> toPT owner onMissing pm m)

        let afterFirstPassFns =
          (afterFirstPass |> Stdlib.List.map (fun m -> m.fns) |> Stdlib.List.flatten)

        let afterFirstPassConstants =
          (afterFirstPass
           |> Stdlib.List.map (fun m -> m.constants)
           |> Stdlib.List.flatten)

        let afterFirstPassTypes =
          (afterFirstPass
           |> Stdlib.List.map (fun m -> m.types)
           |> Stdlib.List.flatten)

        let afterFirstPassTests =
          (afterFirstPass
           |> Stdlib.List.map (fun m -> m.tests)
           |> Stdlib.List.flatten)

        let pm =
          LanguageTools.ProgramTypes.PackageManager.withExtras
            pm
            afterFirstPassTypes
            afterFirstPassConstants
            afterFirstPassFns

        let afterSecondPass =
          modulesWT |> Stdlib.List.map (fun m -> toPT owner onMissing pm m)

        let adjusted =
          afterSecondPass
          |> Stdlib.List.map (fun m ->
            PTModule
              { name = m.name
                types =
                  m.types
                  |> Stdlib.List.map (fun t ->
                    { t with
                        id =
                          afterFirstPassTypes
                          |> Stdlib.List.findFirst (fun original ->
                            original.name == t.name)
                          |> Stdlib.Option.mapWithDefault t.id (fun original ->
                            original.id) })

                constants =
                  m.constants
                  |> Stdlib.List.map (fun c ->
                    { c with
                        id =
                          afterFirstPassConstants
                          |> Stdlib.List.findFirst (fun original ->
                            original.name == c.name)
                          |> Stdlib.Option.mapWithDefault c.id (fun original ->
                            original.id) })
                fns =
                  m.fns
                  |> Stdlib.List.map (fun f ->
                    { f with
                        id =
                          afterFirstPassFns
                          |> Stdlib.List.findFirst (fun original ->
                            original.name == f.name)
                          |> Stdlib.Option.mapWithDefault f.id (fun original ->
                            original.id) })
                tests = m.tests })

        adjusted