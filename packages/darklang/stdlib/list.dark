module Darklang =
  module Stdlib =
    module List =

      /// Drops the last value from <param list>
      let dropLast (list: List<'a>) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          match tail with
          | [] -> []
          | _ ->
            List.append_v0
              (List.singleton_v0 head)
              (PACKAGE.Darklang.Stdlib.List.dropLast tail)


      /// Returns {{Some}} the head (first value) of a list.
      /// Returns {{None}} if the list is empty.
      let head (list: List<'a>) : PACKAGE.Darklang.Stdlib.Option.Option<'a> =
        match list with
        | [] -> PACKAGE.Darklang.Stdlib.Option.Option.None
        | head :: _ -> PACKAGE.Darklang.Stdlib.Option.Option.Some head


      /// If <param list> contains at least one value, returns {{Some}} with a list of
      /// every value other than the first. Otherwise, returns {{None}}.
      let tail (list: List<'a>) : PACKAGE.Darklang.Stdlib.Option.Option<List<'a>> =
        match list with
        | [] -> PACKAGE.Darklang.Stdlib.Option.Option.None
        | _ :: tail -> PACKAGE.Darklang.Stdlib.Option.Option.Some tail


      /// Add element <param val> to front of <type list> <param list>
      let push (list: List<'a>) (value: 'a) : List<'a> =
        List.append_v0 (List.singleton_v0 value) list


      /// Add element <param val> to back of <type list> <param list>
      let pushBack (list: List<'a>) (value: 'a) : List<'a> =
        List.append_v0 list (List.singleton_v0 value)


      /// Returns the last value in <param list>, wrapped in an option (<paramNone> if the list is empty)
      let last (list: List<'a>) : PACKAGE.Darklang.Stdlib.Option.Option<'a> =
        match list with
        | [] -> PACKAGE.Darklang.Stdlib.Option.Option.None
        | head :: tail ->
          match tail with
          | [] -> PACKAGE.Darklang.Stdlib.Option.Option.Some head
          | _ -> PACKAGE.Darklang.Stdlib.List.last tail


      /// Returns a reversed copy of <param list>
      let reverse (list: List<'a>) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          List.append_v0
            (PACKAGE.Darklang.Stdlib.List.reverse tail)
            (List.singleton_v0 head)


      /// Returns the number of values in <param list>
      let ``length`` (list: List<'a>) : Int =
        match list with
        | [] -> 0
        | _ :: tail -> 1 + (PACKAGE.Darklang.Stdlib.List.length tail)


      /// Returns a list of numbers where each element is {{1}} larger than the
      /// previous. You provide the <param lowest> and <param highest> numbers in the list.
      let range (lowest: Int) (highest: Int) : List<Int> =
        if lowest > highest then
          []
        else
          List.append_v0
            (List.singleton_v0 lowest)
            (PACKAGE.Darklang.Stdlib.List.range (lowest + 1) highest)


      /// Returns a single list containing the values of every list directly in <paramlist>
      /// (does not recursively flatten nested lists)
      let flatten (list: List<List<'a>>) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          List.append_v0 head (PACKAGE.Darklang.Stdlib.List.flatten tail)


      /// Returns true if <param list> has no values
      let isEmpty (list: List<'a>) : Bool =
        match list with
        | [] -> true
        | _ -> false


      /// Applies the given function <param fn> to each element of the <param list>.
      let iter (list: List<'a>) (f: 'a -> Unit) : Unit =
        match list with
        | [] -> ()
        | head :: tail ->
          head |> f
          PACKAGE.Darklang.Stdlib.List.iter tail f


      /// Returns {{Some value}} at <param index> in <param list> if <param index> is
      /// less than the length of the list otherwise returns {{None}}.
      let getAt
        (list: List<'a>)
        (index: Int)
        : PACKAGE.Darklang.Stdlib.Option.Option<'a> =
        if index < 0 then
          PACKAGE.Darklang.Stdlib.Option.Option.None
        else
          match list with
          | [] -> PACKAGE.Darklang.Stdlib.Option.Option.None
          | head :: tail ->
            if index == 0 then
              PACKAGE.Darklang.Stdlib.Option.Option.Some head
            else
              PACKAGE.Darklang.Stdlib.List.getAt tail (index - 1)


      /// Returns {{true}} if <param value> is in the list
      let ``member`` (list: List<'a>) (value: 'a) : Bool =
        match list with
        | [] -> false
        | head :: tail ->
          if head == value then
            true
          else
            PACKAGE.Darklang.Stdlib.List.``member`` tail value


      /// Drops the first <param count> values from <param list>
      let drop (list: List<'a>) (count: Int) : List<'a> =
        if count <= 0 then
          list
        else
          match list with
          | [] -> []
          | _ :: tail -> PACKAGE.Darklang.Stdlib.List.drop tail (count - 1)


      /// Drops all but the first <param count> values from <param list>
      let take (list: List<'a>) (count: Int) : List<'a> =
        if count <= 0 then
          []
        else
          match list with
          | [] -> []
          | head :: tail ->
            List.append_v0
              (List.singleton_v0 head)
              (PACKAGE.Darklang.Stdlib.List.take tail (count - 1))


      // can we change the orderof the arguments?
      ///Returns a list containing <param val> repeated <param times> times
      let repeat
        (times: Int)
        (value: 'a)
        : PACKAGE.Darklang.Stdlib.Result.Result<List<'a>, String> =
        if times < 0 then
          PACKAGE.Darklang.Stdlib.Result.Result.Error
            $"Expected `times` to be positive, but it was `{times |> Int.toString}`"
        else if times > 2147483647 then
          PACKAGE.Darklang.Stdlib.Result.Result.Error
            $"Expected `times` to be less than 2147483647, but it was `{times |> Int.toString}`"
        else if times == 0 then
          PACKAGE.Darklang.Stdlib.Result.Result.Ok []
        else
          match PACKAGE.Darklang.Stdlib.List.repeat (times - 1) value with
          | Ok list ->
            PACKAGE.Darklang.Stdlib.Result.Result.Ok(
              PACKAGE.Darklang.Stdlib.List.pushBack list value
            )
          | Error err -> PACKAGE.Darklang.Stdlib.Result.Result.Error err


      /// Returns a single list containing the values of <param list> separated by <param sep>
      let interpose (list: List<'a>) (sep: 'a) : List<'a> =
        match list with
        | [] -> []
        | [ single ] -> [ single ]
        | head :: tail ->
          List.append_v0
            (List.singleton_v0 head)
            (List.append_v0
              (List.singleton_v0 sep)
              (PACKAGE.Darklang.Stdlib.List.interpose tail sep))


      /// Returns a list with the first value from <param l1> then the first value
      /// from <param l2>, then the second value from <param l1> then the second value
      /// other list.
      let interleave (l1: List<'a>) (l2: List<'a>) : List<'a> =
        match l1 with
        | [] -> l2
        | aHead :: aTail ->
          match l2 with
          | [] -> l1
          | bHead :: bTail ->
            List.append_v0
              (List.singleton_v0 aHead)
              (List.append_v0
                (List.singleton_v0 bHead)
                (PACKAGE.Darklang.Stdlib.List.interleave aTail bTail))

      // TODO: CHECK ERROR CASES (when fn doesn't return a bool)
      /// Calls <param f> on every <var val> in <param list>, splitting the list into
      /// two - those values for which {{fn val}} returns {{true}}, and those that
      /// return {{false}}
      let partition (ls: List<'a>) (f: 'a -> Bool) : (List<'a> * List<'a>) =
        match ls with
        | [] -> ([], [])
        | head :: tail ->
          let (trueList, falseList) = PACKAGE.Darklang.Stdlib.List.partition tail f

          if (head |> f) then
            (List.append_v0 (List.singleton_v0 head) trueList, falseList)
          else
            (trueList, List.append_v0 (List.singleton_v0 head) falseList)


      /// Given a <param pairs> list where each value is a tuple of two values (such
      /// lists are constructed by <fn List.zip> and <fn List.zipShortest>), returns
      /// a tuple of two lists, one with every first value, and one with every second
      /// value.
      /// For example, if <fn pairs> is {{[(1,\"x\"), (2,\"y\"), (3,\"z\")]}}, returns
      /// {{([1,2,3], [\"x\",\"y\",\"z\"])}}.
      let unzip (pairs: List<('a * 'b)>) : (List<'a> * List<'b>) =
        match pairs with
        | [] -> ([], [])
        | (a, b) :: tail ->
          let (firsts, seconds) = PACKAGE.Darklang.Stdlib.List.unzip tail

          (List.append_v0 (List.singleton_v0 a) firsts,
           List.append_v0 (List.singleton_v0 b) seconds)


      // If the lists have the same length, returns {{Some list of tuples}} formed from
      // parallel pairs in <param l1> and <param l2>.

      // For example, if <param l1> is {{[1,2,3]}} and <param l2> is
      // {{[\"x\",\"y\",\"z\"]}}, returns {{[(1,\"x\"), (2,\"y\"), (3,\"z\")]}}.

      // See <fn List.unzip> if you want to deconstruct <var list> into <param l1>
      // and <param l2> again.

      // If the lists differ in length, returns {{None}} (consider
      // <fn List.zipShortest> if you want to drop values from the longer list
      // instead).
      let zip
        (l1: List<'a>)
        (l2: List<'b>)
        : PACKAGE.Darklang.Stdlib.Option.Option<List<('a * 'b)>> =
        if
          (PACKAGE.Darklang.Stdlib.List.length l1)
          != (PACKAGE.Darklang.Stdlib.List.length l2)
        then
          PACKAGE.Darklang.Stdlib.Option.Option.None
        else
          match l1 with
          | [] -> PACKAGE.Darklang.Stdlib.Option.Option.Some []
          | aHead :: aTail ->
            match l2 with
            | [] -> PACKAGE.Darklang.Stdlib.Option.Option.Some []
            | bHead :: bTail ->
              match PACKAGE.Darklang.Stdlib.List.zip aTail bTail with
              | Some zipped ->
                PACKAGE.Darklang.Stdlib.Option.Option.Some(
                  List.append_v0 (List.singleton_v0 (aHead, bHead)) zipped
                )
              | None -> PACKAGE.Darklang.Stdlib.Option.Option.None


      // Returns a list of parallel pairs from <param as> and <param bs>.
      // If the lists differ in length, values from the longer list are dropped.
      // For example, if <param as> is {{[1,2]}} and <param bs> is
      // {{[\"x\",\"y\",\"z\"]}}, returns {{[(1,\"x\"), (2,\"y\")]}}.
      // Use <fn List.zip> if you want to enforce equivalent lengths for <param as>
      // and <param bs>.
      // See <fn List.unzip> if you want to deconstruct the result into <param as>
      // and <param bs> again.

      let zipShortest (as_: List<'a>) (bs: List<'b>) : List<('a * 'b)> =
        match as_ with
        | [] -> []
        | aHead :: aTail ->
          match bs with
          | [] -> []
          | bHead :: bTail ->
            List.append_v0
              (List.singleton_v0 (aHead, bHead))
              (PACKAGE.Darklang.Stdlib.List.zipShortest aTail bTail)


      // Calls <param fn> on every <var val> in <param list>, returning a list of the
      // results of those calls.
      // Consider <fn List.filterMap> if you also want to drop some of the values.
      let map (list: List<'a>) (fn: 'a -> 'b) : List<'b> =
        match list with
        | [] -> []
        | head :: tail ->
          List.append_v0
            (List.singleton_v0 (head |> fn))
            (PACKAGE.Darklang.Stdlib.List.map tail fn)

      // TODO : CHECK ERROR CASES (when fn doesn't return a bool)
      /// Return the longest prefix of <param list> which satisfies the predicate <param fn>
      let takeWhile (list: List<'a>) (fn: 'a -> Bool) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          if (head |> fn) then
            List.append_v0
              (List.singleton_v0 head)
              (PACKAGE.Darklang.Stdlib.List.takeWhile tail fn)
          else
            []


      // TODO : CHECK ERROR CASES (when fn doesn't return a bool)
      /// Drops the longest prefix of <param list> which satisfies the predicate <param val>
      let dropWhile (list: List<'a>) (fn: 'a -> Bool) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          if (head |> fn) then
            PACKAGE.Darklang.Stdlib.List.dropWhile tail fn
          else
            list


      // TODO : CHECK ERROR CASES (when fn doesn't return a bool)
      // Calls <param f> on every <var val> in <param list>, returning a list of only
      // those values for which {{fn val}} returns {{true}}.
      // Preserves the order of values that were not dropped. Consider <fn
      // List.filterMap> if you also want to transform the values.
      let filter (list: List<'a>) (f: 'a -> Bool) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          if (head |> f) then
            List.append_v0
              (List.singleton_v0 head)
              (PACKAGE.Darklang.Stdlib.List.filter tail f)
          else
            PACKAGE.Darklang.Stdlib.List.filter tail f



      // TODO : handle error case where fn doesn't return an option
      // Calls <param fn> on every <var val> in <param list>, returning a list that
      // drops some values (filter) and transforms others (map).
      // If {{fn val}} returns {{None}}, drops <var val> from the list.
      // If {{fn val}} returns {{Some newValue}}, replaces <var val> with <var newValue>.
      // Preserves the order of values that were not dropped.
      // This function combines <fn List.filter> and <fn List.map>.

      // let filterMap
      //   (list: List<'a>)
      //   (fn: 'a -> PACKAGE.Darklang.Stdlib.Option.Option<'b>)
      //   : List<'b> =
      //   match list with
      //   | [] -> []
      //   | head :: tail ->
      //     match (head |> fn) with
      //     | Some newValue ->
      //       List.append_v0
      //         (List.singleton_v0 newValue)
      //         (PACKAGE.Darklang.Stdlib.List.filterMap tail fn)
      //     | None -> PACKAGE.Darklang.Stdlib.List.filterMap tail fn
      // | e ->
      //   Test.runtimeError
      //     $"Expected `fn` to return a PACKAGE.Darklang.Stdlib.Option.Option<'b>, but it returned `{e}`"


      // TODO : CHECK ERROR CASES (when fn doesn't return a bool)
      /// Return {{true}} if all elements in the list meet the function's criteria, else {{false}}
      let all (list: List<'a>) (fn: 'a -> Bool) : Bool =
        match list with
        | [] -> true
        | head :: tail ->
          if (head |> fn) then
            PACKAGE.Darklang.Stdlib.List.all tail fn
          else
            false



      // TODO : CHECK ERROR CASES (when the list elements are different types)
      /// Returns the passed list, with only unique values, where uniqueness is based
      /// on the result of <param fn>. Only one of each value will be returned, but the
      /// order will not be maintained.

      let uniqueBy (list: List<'a>) (fn: 'a -> 'b) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          let uniqueTail = PACKAGE.Darklang.Stdlib.List.uniqueBy tail fn

          if
            (PACKAGE.Darklang.Stdlib.List.``member``
              (List.map_v0 uniqueTail fn)
              (head |> fn))
          then
            uniqueTail
          else
            List.append_v0 (List.singleton_v0 head) uniqueTail

      // TODO : CHECK ERROR CASES (when the list elements are different types)
      // Returns the passed list, with only unique values.
      // Only one of each value will be returned, but the
      // order will not be maintained.
      let unique (list: List<'a>) : List<'a> =
        match list with
        | [] -> []
        | head :: tail ->
          let uniqueTail = PACKAGE.Darklang.Stdlib.List.unique tail

          if (PACKAGE.Darklang.Stdlib.List.``member`` uniqueTail head) then
            uniqueTail
          else
            List.append_v0 (List.singleton_v0 head) uniqueTail

      /// Folds <param list> into a single value, by repeatedly applying <param fn> to any two pairs.
      // let fold (list: List<'a>) (init: 'b) (fn: 'b -> 'a -> 'b) : 'b =
      //   match list with
      //   | [] -> init
      //   | head :: tail ->
      //     // todo check if we can pipe 2 args into fn
      //     let init = (init |> fn head)
      //     PACKAGE.Darklang.Stdlib.List.fold tail init fn


      /// Returns {{Some firstMatch}} where <var firstMatch> is the first value of the
      /// list for which <param fn> returns {{true}}. Returns {{None}} if no such
      /// value exists
      let findFirst
        (list: List<'a>)
        (fn: 'a -> Bool)
        : PACKAGE.Darklang.Stdlib.Option.Option<'a> =
        match list with
        | [] -> PACKAGE.Darklang.Stdlib.Option.Option.None
        | head :: tail ->
          if (head |> fn) then
            PACKAGE.Darklang.Stdlib.Option.Option.Some head
          else
            PACKAGE.Darklang.Stdlib.List.findFirst tail fn