module Darklang =
  module Stdlib =
    module String =

      /// Returns a string containing a single '\n'
      let newline = "\n"

      /// Truncates the string <param s> to the specified <param length> and appends an ellipsis ("...")
      /// to it if the original string exceeds the given length. Otherwise, returns the original string.
      let ellipsis (s: String) (length: Int) : String =
        if String.length s > length then
          (String.slice_v0 s 0 length) ++ "..."
        else
          s

      /// Returns 'a' or 'an' (the indefinite article) for a string, based on
      /// whether it begins with a vowel
      let articleFor (nextWord: String) : String =
        let vowels = [ 'A'; 'E'; 'I'; 'O'; 'U'; 'a'; 'e'; 'i'; 'o'; 'u' ]

        match String.head nextWord with
        | None -> ""
        | Some c ->
          if String.length nextWord > 1 && Bool.not (Char.isASCIILetter c) then
            articleFor (String.dropFirst nextWord 1)
          else if List.``member`` vowels c then
            "an"
          else
            "a"


      /// Returns {{true}} if <param s> is the empty string {{\"\"}
      let isEmpty (s: String) : Bool = s == ""


      /// Concatenates the two strings by prepending <param s2> to <param s1> and
      /// returns the joined string
      let prepend (s1: String) (s2: String) : String = s2 ++ s1


      /// Returns the list of characters as a string
      let fromList (lst: List<Char>) : String =
        (List.map lst (fun c -> Char.toString c)) |> String.join ""


      /// Converts a <type Char> to a <type String>
      let fromChar (c: Char) : String = Char.toString c


      /// Returns the first <param characterCount> characters of <param string>, as a String.
      /// If <param characterCount> is longer than <param string>, returns <param string>.
      /// If <param characterCount> is negative, returns the empty string."
      let first (string: String) (characterCount: Int) : String =
        if characterCount < 0 then ""
        else if characterCount > String.length string then string
        else String.slice_v0 string 0 characterCount


      /// Returns the last <param characterCount> characters of <param string>, as a String.
      /// If <param characterCount> is longer than <param string>, returns <param string>.
      /// If <param characterCount> is negative, returns the empty string.
      let last (string: String) (characterCount: Int) : String =
        if characterCount < 0 then
          ""
        else if characterCount > String.length string then
          string
        else
          String.slice_v0
            string
            (String.length string - characterCount)
            (String.length string)


      /// Returns all but the last <param characterCount> characters of <param string>, as a String.
      /// If <param characterCount> is longer than <param string>, returns the empty string.
      /// If <param characterCount> is negative, returns <param string>.
      let dropLast (string: String) (characterCount: Int) : String =
        if characterCount < 0 then
          string
        else if characterCount > String.length string then
          ""
        else
          String.slice_v0 string 0 (String.length string - characterCount)


      /// Returns all but the first <param characterCount> characters of <param string>, as a <type String>.
      /// If <param characterCount> is longer than <param string>, returns the empty string.
      /// If <param characterCount> is negative, returns <param string>.
      let dropFirst (string: String) (characterCount: Int) : String =
        if characterCount < 0 then
          string
        else if characterCount > String.length string then
          ""
        else
          String.slice_v0 string characterCount (String.length string)


      let repeat (string: String) (count: Int) : String =
        if count <= 0 then
          ""
        else
          string ++ PACKAGE.Darklang.Stdlib.String.repeat string (count - 1)


      /// If <param string> is shorter than <param goalLength> characters, returns a
      /// copy of <param string> starting with enough copies of <param padWith> for the
      /// result have <param goalLength>. A returning value is wrapped in a {{Result}}.
      /// If the <param string> is longer than <param goalLength>, returns an unchanged copy of <param string>

      let padStart
        (string: String)
        (padWith: String)
        (goalLength: Int)
        : PACKAGE.Darklang.Stdlib.Result.Result<String, String> =
        if String.length padWith != 1 then
          PACKAGE.Darklang.Stdlib.Result.Result.Error
            $"Expected `padWith` to be 1 character long, but it was `\"{padWith}\"`"
        else if String.length string >= goalLength then
          PACKAGE.Darklang.Stdlib.Result.Result.Ok string
        else
          let padCount = goalLength - String.length string
          let pad = PACKAGE.Darklang.Stdlib.String.repeat padWith padCount
          PACKAGE.Darklang.Stdlib.Result.Result.Ok(pad ++ string)


      /// If <param string> is shorter than <param goalLength> characters, returns a
      /// copy of <param string> ending with enough copies of <param padWith> for the
      /// result have <param goalLength>. A returning value is wrapped in a {{Result}}.
      /// If the <param string> is longer than <param goalLength>, returns an unchanged copy of <param string>.
      let padEnd
        (string: String)
        (padWith: String)
        (goalLength: Int)
        : PACKAGE.Darklang.Stdlib.Result.Result<String, String> =
        if String.length padWith != 1 then
          PACKAGE.Darklang.Stdlib.Result.Result.Error
            $"Expected `padWith` to be 1 character long, but it was `\"{padWith}\"`"
        else if String.length string >= goalLength then
          PACKAGE.Darklang.Stdlib.Result.Result.Ok string
        else
          let padCount = goalLength - String.length string
          let pad = PACKAGE.Darklang.Stdlib.String.repeat padWith padCount
          PACKAGE.Darklang.Stdlib.Result.Result.Ok(string ++ pad)


      /// Checks if <param subject> starts with <param prefix>
      let startsWith (subject: String) (prefix: String) : Bool =
        String.slice_v0 subject 0 (String.length prefix) == prefix


      /// Checks if <param subject> ends with <param suffix>
      let endsWith (subject: String) (suffix: String) : Bool =
        String.slice_v0
          subject
          (String.length subject - String.length suffix)
          (String.length subject)
        == suffix


      let toOrdinal (n: Int) : String =
        let suffix =
          match n % 10 with
          | 1 -> "st"
          | 2 -> "nd"
          | 3 -> "rd"
          | _ -> "th"

        (Int.toString n) ++ suffix


      let splitOnNewline (str: String) : List<String> =
        if str == "" then [] else String.split str "\n"
      /// Iterate over each Character (EGC, not byte) in the string, performing the
      /// operation in <param fn> on each one.
      let map (s: String) (fn: Char -> Char) : String =
        s |> String.toList |> List.map fn |> PACKAGE.Darklang.Stdlib.String.fromList


      /// Replace all instances on <param searchFor> in <param s> with <param replaceWith>
      /// Replaces all instances of <param searchFor> in <param s> with <param replaceWith>.
      let replaceAll (s: String) (searchFor: String) (replaceWith: String) : String =
        match s, searchFor with
        | "", "" -> replaceWith
        | "", _ -> s
        | _, "" ->
          s
          |> String.toList
          |> List.map (fun c ->
            PACKAGE.Darklang.Stdlib.Char.toString c ++ replaceWith)
          |> String.join ""
          |> PACKAGE.Darklang.Stdlib.String.prepend replaceWith
        | _ -> s |> String.split searchFor |> String.join replaceWith


      /// Returns the length of the string
      let length (s: String) : Int =
        s |> String.toList |> PACKAGE.Darklang.Stdlib.List.length


      // is it bad to do it this way?
      /// Concatenates the two strings by appending <param s2> to <param s1> and returns the joined string.
      let append (s1: String) (s2: String) : String = $"{s1}{s2}"


      /// Reverses <param string>
      let reverse (string: String) : String =
        string
        |> String.toList
        |> PACKAGE.Darklang.Stdlib.List.reverse
        |> PACKAGE.Darklang.Stdlib.String.fromList


      /// Combines a list of strings with the provided separator
      let join (l: List<String>) (separator: String) : String =
        (List.map l (fun s -> s ++ separator)) |> String.join ""


      /// Escape an untrusted string in order to include it safely in HTML output
      let htmlEscape (html: String) : String =
        html
        |> String.toList
        |> List.map (fun c ->
          match c with
          | '<' -> "&lt;"
          | '>' -> "&gt;"
          | '&' -> "&amp;"
          // include these for html-attribute-escaping
          // even though they're not strictly necessary
          // for html-escaping proper.
          | '"' -> "&quot;"
          // &apos; doesn't work in IE....
          | ''' -> "&#x27;"
          | _ -> PACKAGE.Darklang.Stdlib.Char.toString c)
        |> PACKAGE.Darklang.Stdlib.String.join ""


      // this is a helper function for slice
      let normalize (i: Int) (len: Int) : Int =
        (if i < 0 then len + i else i)
        |> PACKAGE.Darklang.Stdlib.Int.min len
        |> PACKAGE.Darklang.Stdlib.Int.max 0


      /// Returns the substring of <param string> between the <param from> and <param to> indices.
      /// Negative indices start counting from the end of <param string>.
      let slice (s: String) (f: Int) (l: Int) : String =
        let len = PACKAGE.Darklang.Stdlib.String.length s
        let f = f |> PACKAGE.Darklang.Stdlib.String.normalize len
        let l = l |> PACKAGE.Darklang.Stdlib.String.normalize len
        let l = if f > l then f else l

        s
        |> String.toList
        |> PACKAGE.Darklang.Stdlib.List.drop f
        |> PACKAGE.Darklang.Stdlib.List.take (l - f)
        |> PACKAGE.Darklang.Stdlib.String.fromList


      /// Returns a copy of <param str> with all leading whitespace removed. 'whitespace'
      /// here means all Unicode characters with the {{White_Space}} property, which
      /// includes {{\" \"}}, {{\"\\t\"}} and {{\"\\n\"}}
      let trimStart (str: String) : String =
        str
        |> String.toList
        |> List.dropWhile (fun c ->
          c == ' ' || c == '\t' || c == '\n' || c == '\u2003')
        |> PACKAGE.Darklang.Stdlib.String.fromList


      /// Returns a copy of the string <param str> with all trailing whitespace removed.
      /// 'whitespace' here means all Unicode characters with the {{White_Space}}
      /// property, which includes {{\" \"}}, {{\"\\t\"}}, and {{\"\\n\"}}.
      let trimEnd (str: String) : String =
        str
        |> String.toList
        |> PACKAGE.Darklang.Stdlib.List.reverse
        |> List.dropWhile (fun c ->
          c == ' ' || c == '\t' || c == '\n' || c == '\u2003')
        |> PACKAGE.Darklang.Stdlib.List.reverse
        |> PACKAGE.Darklang.Stdlib.String.fromList


      /// Returns a copy of <param str> with all leading and trailing whitespace
      /// removed. 'whitespace' here means all Unicode characters with the
      /// {{White_Space}} property, which includes {{\" \"}}, {{\"\\t\"}} and
      /// {{\"\\n\"}}
      let trim (str: String) : String =
        str
        |> PACKAGE.Darklang.Stdlib.String.trimStart
        |> PACKAGE.Darklang.Stdlib.String.trimEnd


      /// Checks if <param lookingIn> contains <param searchingFor>
      let contains (lookingIn: String) (searchingFor: String) : Bool =
        match String.indexOf lookingIn searchingFor with
        | Some _ -> true
        | None -> false


      /// Returns the string, uppercased
      let toUppercase (s: String) : String =
        s
        |> String.toList
        |> List.map (fun c -> Char.toUppercase c)
        |> PACKAGE.Darklang.Stdlib.String.fromList


      /// Returns the string, lowercased
      let toLowercase (s: String) : String =
        s
        |> String.toList
        |> List.map (fun c -> Char.toLowercase c)
        |> PACKAGE.Darklang.Stdlib.String.fromList
