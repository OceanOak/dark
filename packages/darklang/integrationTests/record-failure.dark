module Darklang =
  module Cli =
    module IntegrationTests =
      module FailureRecorder =

        // Types for recording results
        type RecordingResult =
          | Success of gifPath: String
          | SkippedNoVhs
          | Failed of error: String

        // Helper functions for paths and directories
        let getScriptDir () : String = "./tests/integration/cli"
        let getProjectRoot () : String = "."
        let getFailureGifsDir () : String = $"{getScriptDir ()}/failure-gifs"
        let getTapesDir () : String = $"{getScriptDir ()}/tapes"

        // Get absolute path for a relative path
        let getAbsolutePath (relativePath: String) : String =
          let result = Builtin.cliExecute $"realpath {relativePath}"

          if result.exitCode == 0L then
            Stdlib.String.trim result.stdout
          else
            relativePath // Fallback to relative path

        // Check if VHS is available
        let checkVhsAvailable () : Bool =
          let result = Builtin.cliExecute "command -v vhs"
          result.exitCode == 0L

        // Create necessary directories
        let createDirectories () : Stdlib.Result.Result<Unit, String> =
          let result1 = Builtin.cliExecute $"mkdir -p {getFailureGifsDir ()}"

          if result1.exitCode == 0L then
            let result2 = Builtin.cliExecute $"mkdir -p {getTapesDir ()}"

            if result2.exitCode == 0L then
              Stdlib.Result.Result.Ok()
            else
              Stdlib.Result.Result.Error
                $"Failed to create tapes directory: {result2.stderr}"
          else
            Stdlib.Result.Result.Error
              $"Failed to create failure-gifs directory: {result1.stderr}"

        // Generate timestamp in format YYYYMMDD-HHMMSS
        let generateTimestamp () : String =
          let result = Builtin.cliExecute "date +%Y%m%d-%H%M%S"

          if result.exitCode == 0L then
            Stdlib.String.trim result.stdout
          else
            "unknown-time"

        // Sanitize test name for safe filename
        let sanitizeTestName (testName: String) : String =
          testName
          |> Stdlib.String.toLowercase
          |> Stdlib.String.replaceAll " " "-"
          // Simple character filtering for safety
          |> Stdlib.String.replaceAll "(" ""
          |> Stdlib.String.replaceAll ")" ""
          |> Stdlib.String.replaceAll "[" ""
          |> Stdlib.String.replaceAll "]" ""
          |> Stdlib.String.replaceAll "/" ""
          |> Stdlib.String.replaceAll "\\" ""

        // Create tape file using Dark's built-in file operations (UPDATED - Option 1)
        let createTapeFileWithBuiltin
          (testName: String)
          (command: String)
          (tapeFile: String)
          (gifPath: String)
          : Stdlib.Result.Result<Unit, String> =
          let absoluteGifPath = getAbsolutePath gifPath

          // Build the content string properly using Dark's string concatenation
          let content =
            "Output \""
            ++ absoluteGifPath
            ++ "\"\n"
            ++ "Set FontSize 14\n"
            ++ "Set Width 1200\n"
            ++ "Set Height 600\n"
            ++ "Set TypingSpeed 50ms\n"
            ++ "Set Theme \"Dracula\"\n"
            ++ "\n"
            ++ "Type \"# Test failure: "
            ++ testName
            ++ "\"\n"
            ++ "Enter\n"
            ++ "Sleep 1s\n"
            ++ "\n"
            ++ "Type \"# Command: "
            ++ command
            ++ "\"\n"
            ++ "Enter\n"
            ++ "Sleep 1s\n"
            ++ "\n"
            ++ "Type \""
            ++ command
            ++ "\"\n"
            ++ "Enter\n"
            ++ "Sleep 3s\n"
            ++ "\n"
            ++ "Type \"# Recording complete\"\n"
            ++ "Enter\n"
            ++ "Sleep 2s"

          // Use Dark's built-in file writing instead of shell commands (FIXED parameter order)
          match Builtin.fileWrite (Stdlib.String.toBytes content) tapeFile with
          | Ok _ -> Stdlib.Result.Result.Ok()
          | Error e -> Stdlib.Result.Result.Error e

        // Delete file if it exists
        let deleteFile (filePath: String) : Unit =
          let result = Builtin.cliExecute $"rm -f \"{filePath}\""
          // Ignore errors when deleting
          ()

        // Run VHS recording with better error handling
        let runVhsRecording (tapeFile: String) : Stdlib.Result.Result<Unit, String> =
          // Get absolute paths to avoid issues when changing directories
          let absoluteTapeFile = getAbsolutePath tapeFile
          let projectRoot = getProjectRoot ()
          let absoluteProjectRoot = getAbsolutePath projectRoot

          // Verify the tape file exists before running VHS
          let checkFile = Builtin.cliExecute $"test -f \"{absoluteTapeFile}\""

          if checkFile.exitCode != 0L then
            Stdlib.Result.Result.Error
              $"Tape file does not exist: {absoluteTapeFile}"
          else
            // Change to project root and run VHS with absolute path
            let command =
              $"cd \"{absoluteProjectRoot}\" && timeout 60s vhs \"{absoluteTapeFile}\""

            let result = Builtin.cliExecute command

            if result.exitCode == 0L then
              Stdlib.Result.Result.Ok()
            else
              // Provide more detailed error information
              let errorMsg =
                $"VHS failed with exit code {Stdlib.Int64.toString result.exitCode}"

              let stderrMsg =
                if Stdlib.String.isEmpty result.stderr then
                  "No stderr output"
                else
                  result.stderr

              let stdoutMsg =
                if Stdlib.String.isEmpty result.stdout then
                  "No stdout output"
                else
                  result.stdout

              Stdlib.Result.Result.Error
                $"{errorMsg}. Stderr: {stderrMsg}. Stdout: {stdoutMsg}"

        // Main recording function (UPDATED to use built-in file writing)
        let recordFailure (testName: String) (command: String) : RecordingResult =
          // Check if VHS is available
          if Stdlib.Bool.not (checkVhsAvailable ()) then
            Builtin.printLine "‚ö†Ô∏è  VHS not found - skipping failure recording"

            Builtin.printLine
              "Install with: go install github.com/charmbracelet/vhs@latest"

            RecordingResult.SkippedNoVhs
          else
            // Create directories
            match createDirectories () with
            | Error e -> RecordingResult.Failed e
            | Ok _ ->
              // Generate filename components
              let timestamp = generateTimestamp ()
              let safeTestName = sanitizeTestName testName

              // Create file paths
              let tapeFile =
                $"{getTapesDir ()}/failure-{safeTestName}-{timestamp}.tape"

              let gifName = $"{safeTestName}-failure-{timestamp}.gif"
              let gifPath = $"{getFailureGifsDir ()}/{gifName}"

              // UPDATED: Use built-in file writing instead of shell commands
              match createTapeFileWithBuiltin testName command tapeFile gifPath with
              | Error e -> RecordingResult.Failed $"Failed to create tape file: {e}"
              | Ok _ ->
                Builtin.printLine $"üé¨ Recording failure GIF for {testName}..."

                // Run VHS recording
                match runVhsRecording tapeFile with
                | Ok _ ->
                  // Success - clean up and report
                  deleteFile tapeFile

                  Builtin.printLine
                    $"‚úÖ Failure GIF generated: failure-gifs/{gifName}"

                  Builtin.printLine
                    $"üìÅ View at: tests/integration/cli/failure-gifs/{gifName}"

                  RecordingResult.Success gifPath

                | Error e ->
                  // Failed - don't clean up tape file for debugging
                  Builtin.printLine "‚ùå Failed to generate VHS recording"
                  Builtin.printLine $"üêõ Debug: VHS error: {e}"

                  Builtin.printLine
                    $"üêõ Debug: Tape file left at: {tapeFile} for inspection"

                  RecordingResult.Failed $"VHS recording failed: {e}"

        // Validate command line arguments
        let validateArgs
          (args: List<String>)
          : Stdlib.Result.Result<(String * String), String> =
          match args with
          | [ testName; command ] -> Stdlib.Result.Result.Ok(testName, command)
          | _ -> Stdlib.Result.Result.Error "Invalid arguments"

        // Show usage information
        let showUsage () : Unit =
          Builtin.printLine "VHS Failure Recorder for Darklang CLI Tests"
          Builtin.printLine ""
          Builtin.printLine "Usage: record-failure <test-name> <command>"
          Builtin.printLine ""
          Builtin.printLine "Arguments:"
          Builtin.printLine "  test-name    Name of the test that failed"
          Builtin.printLine "  command      Command that failed (for reproduction)"
          Builtin.printLine ""
          Builtin.printLine "Example:"
          Builtin.printLine "  record-failure 'help-test' './scripts/run-cli help'"
          Builtin.printLine ""

          Builtin.printLine
            "This tool creates a VHS recording (GIF) showing the failed command"

          Builtin.printLine "for debugging purposes. The recording is saved in:"
          Builtin.printLine "  tests/integration/cli/failure-gifs/"

        // Entry point for command-line execution
        let main (args: List<String>) : Int64 =
          match validateArgs args with
          | Error _ ->
            Builtin.printLine "‚ùå Error: Invalid number of arguments"
            Builtin.printLine ""
            showUsage ()
            1L

          | Ok(testName, command) ->
            match recordFailure testName command with
            | Success _ -> 0L
            | SkippedNoVhs -> 0L // Not an error, just unavailable
            | Failed error ->
              Builtin.printLine $"‚ùå Recording failed: {error}"
              1L

        // Helper function for integration with other test scripts
        let recordFailureForTest (testName: String) (command: String) : Bool =
          match recordFailure testName command with
          | Success _ -> true
          | SkippedNoVhs -> true // Consider this successful (not available)
          | Failed _ -> false