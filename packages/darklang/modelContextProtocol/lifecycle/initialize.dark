// Initialization for the Model Context Protocol
module Darklang.ModelContextProtocol.LifeCycle.InitializeRequest

/// Client capabilities for the Model Context Protocol
type ClientCapabilities =
  { elicitation: Stdlib.Option.Option<Json>
    experimental: Stdlib.Option.Option<Dict<Json>>
    roots: Stdlib.Option.Option<RootsClientCapabilities>
    sampling: Stdlib.Option.Option<Json> }

/// Roots client capabilities  
type RootsClientCapabilities =
  { listChanged: Stdlib.Option.Option<Bool> }

/// Parameters for the initialize request
type InitializeParams =
  { clientInfo: Stdlib.Option.Option<ClientInfo>
    capabilities: ClientCapabilities
    trace: Stdlib.Option.Option<TraceLevel> }

/// Client information
type ClientInfo =
  { name: String
    version: Stdlib.Option.Option<String> }

let fromJson (json: Json) : Stdlib.Result.Result<InitializeParams, String> =
  match json with
  | Object fields ->
    // Parse clientInfo if present
    let clientInfoResult =
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "clientInfo") with
      | Some clientInfoEntry ->
        match clientInfoEntry with
        | (_, Object clientInfoFields) ->
          match Stdlib.List.findFirst clientInfoFields (fun (k, _) -> k == "name") with
          | Some nameEntry ->
            match nameEntry with
            | (_, String name) ->
              let version =
                match Stdlib.List.findFirst clientInfoFields (fun (k, _) -> k == "version") with
                | Some versionEntry ->
                  match versionEntry with
                  | (_, String v) -> Stdlib.Option.Option.Some v
                  | _ -> Stdlib.Option.Option.None
                | None -> Stdlib.Option.Option.None

              Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some (ClientInfo { name = name; version = version }))
            | _ -> Stdlib.Result.Result.Error "clientInfo.name must be a string"
          | None -> Stdlib.Result.Result.Error "clientInfo.name is required"
        | (_, _) -> Stdlib.Result.Result.Error "clientInfo must be an object"
      | None -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None

    // Parse capabilities (required)
    let capabilitiesResult =
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "capabilities") with
      | Some capEntry ->
        match capEntry with
        | (_, Object capFields) ->
          // Parse elicitation
          let elicitation =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "elicitation") with
            | Some (_, json) -> Stdlib.Option.Option.Some json
            | None -> Stdlib.Option.Option.None

          // Parse experimental
          let experimental =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "experimental") with
            | Some (_, Object expFields) -> 
              let dict = Stdlib.List.fold Stdlib.Dict.empty expFields (fun acc (key, value) ->
                Stdlib.Dict.set acc key value
              )
              Stdlib.Option.Option.Some dict
            | _ -> Stdlib.Option.Option.None

          // Parse roots
          let roots =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "roots") with
            | Some (_, Object rootFields) ->
              let listChanged =
                match Stdlib.List.findFirst rootFields (fun (k, _) -> k == "listChanged") with
                | Some (_, Bool b) -> Stdlib.Option.Option.Some b
                | _ -> Stdlib.Option.Option.None
              Stdlib.Option.Option.Some (RootsClientCapabilities { listChanged = listChanged })
            | _ -> Stdlib.Option.Option.None

          // Parse sampling  
          let sampling =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "sampling") with
            | Some (_, json) -> Stdlib.Option.Option.Some json
            | None -> Stdlib.Option.Option.None

          Stdlib.Result.Result.Ok (ClientCapabilities { 
            elicitation = elicitation;
            experimental = experimental;
            roots = roots;
            sampling = sampling
          })
        | (_, _) -> Stdlib.Result.Result.Error "capabilities must be an object"
      | None -> Stdlib.Result.Result.Error "capabilities is required"

    // Parse trace if present
    let traceResult =
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "trace") with
      | Some traceEntry ->
        match traceEntry with
        | (_, String "off") -> Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some TraceLevel.Off)
        | (_, String "messages") -> Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some TraceLevel.Messages)
        | (_, String "verbose") -> Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some TraceLevel.Verbose)
        | (_, _) -> Stdlib.Result.Result.Error "trace must be one of: 'off', 'messages', 'verbose'"
      | None -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None

    // Combine all results
    match (clientInfoResult, capabilitiesResult, traceResult) with
    | (Ok clientInfo, Ok capabilities, Ok trace) ->
        Stdlib.Result.Result.Ok (InitializeParams { clientInfo = clientInfo; capabilities = capabilities; trace = trace })
    | (Error e, _, _) -> Stdlib.Result.Result.Error e
    | (_, Error e, _) -> Stdlib.Result.Result.Error e
    | (_, _, Error e) -> Stdlib.Result.Result.Error e
  | _ -> Stdlib.Result.Result.Error "params must be an object"

let toJson (params: InitializeParams) : Json =
  let clientInfoJson =
    match params.clientInfo with
    | Some info ->
      let fields = [("name", Json.String info.name)]
      let fieldsWithVersion =
        match info.version with
        | Some v -> fields @ [("version", Json.String v)]
        | None -> fields
      Stdlib.Option.Option.Some ("clientInfo", Json.Object fieldsWithVersion)
    | None -> Stdlib.Option.Option.None

  let resourceCapabilitiesJson =
    match params.capabilities.resources with
    | Some res ->
      let fields = []
      let fieldsWithListChanged =
        match res.listChanged with
        | Some b -> fields @ [("listChanged", Json.Bool b)]
        | None -> fields
      let fieldsWithSubscribe =
        match res.subscribe with
        | Some b -> fieldsWithListChanged @ [("subscribe", Json.Bool b)]
        | None -> fieldsWithListChanged
      Stdlib.Option.Option.Some ("resources", Json.Object fieldsWithSubscribe)
    | None -> Stdlib.Option.Option.None

  let toolCapabilitiesJson =
    match params.capabilities.tools with
    | Some tools ->
      let fields = []
      let fieldsWithListChanged =
        match tools.listChanged with
        | Some b -> fields @ [("listChanged", Json.Bool b)]
        | None -> fields
      Stdlib.Option.Option.Some ("tools", Json.Object fieldsWithListChanged)
    | None -> Stdlib.Option.Option.None

  let capabilitiesFields =
    [resourceCapabilitiesJson; toolCapabilitiesJson]
    |> Stdlib.Option.values

  let traceJson =
    match params.trace with
    | Some Off -> Stdlib.Option.Option.Some ("trace", Json.String "off")
    | Some Messages -> Stdlib.Option.Option.Some ("trace", Json.String "messages")
    | Some Verbose -> Stdlib.Option.Option.Some ("trace", Json.String "verbose")
    | None -> Stdlib.Option.Option.None

  let fields =
    [clientInfoJson; Stdlib.Option.Option.Some ("capabilities", Json.Object capabilitiesFields); traceJson]
    |> Stdlib.Option.values

  Json.Object fields

/// Result of the initialize request
module InitializeResult =
  type InitializeResult =
    { serverInfo: Stdlib.Option.Option<ServerInfo>
      capabilities: ServerCapabilities }

  let toJson (result: InitializeResult) : Json =
    let serverInfoJson =
      match result.serverInfo with
      | Some info ->
        Stdlib.Option.Option.Some ((
          "serverInfo",
          Json.Object [
            ("name", Json.String info.name);
            ("version", Json.String info.version)
          ]
        ))
      | None -> Stdlib.Option.Option.None

    let resourceCapabilitiesJson =
      match result.capabilities.resources with
      | Some res ->
        Stdlib.Option.Option.Some ((
          "resources",
          Json.Object [
            ("supportsResourceListing", Json.Bool res.supportsResourceListing);
            ("supportsResourceTemplates", Json.Bool res.supportsResourceTemplates)
          ]
        ))
      | None -> Stdlib.Option.Option.None

    let toolCapabilitiesJson =
      match result.capabilities.tools with
      | Some tools ->
        Stdlib.Option.Option.Some ((
          "tools",
          Json.Object [
            ("supportsToolListing", Json.Bool tools.supportsToolListing)
          ]
        ))
      | None -> Stdlib.Option.Option.None

    let capabilitiesFields =
      [resourceCapabilitiesJson; toolCapabilitiesJson]
      |> Stdlib.Option.values

    let fields =
      [serverInfoJson; Stdlib.Option.Option.Some (("capabilities", Json.Object capabilitiesFields))]
      |> Stdlib.Option.values

    Json.Object fields