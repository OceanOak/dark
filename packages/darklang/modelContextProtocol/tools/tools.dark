// Tool-related functionality for the Model Context Protocol
// Enables LLMs to perform actions through the server (expose executable functions that can be invoked by the client)

module Darklang =
  module ModelContextProtocol =
    module Tools =
      // <aliases>
      type Json = Stdlib.AltJson.Json
      type ToolDescription = Darklang.ModelContextProtocol.ToolDescription
      type ToolAnnotations = Darklang.ModelContextProtocol.ToolAnnotations
      type ToolId = Darklang.ModelContextProtocol.ToolId
      // </aliases>
      /// Schema for the listTools request
      module ListToolsRequest =
        type ListToolsParams = Unit

        let fromJson (json: Json) : Stdlib.Result.Result<ListToolsParams, String> =
          Stdlib.Result.Result.Ok ()

        let toJson (_idk: ListToolsParams) : Json =
          Json.Object []

      /// Schema for the callTool request
      module CallToolRequest =
        type CallToolParams =
          { name: ToolId
            arguments: Json }

        let fromJson (json: Json) : Stdlib.Result.Result<CallToolParams, String> =
          match json with
          | Object fields ->
            let nameResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "name") with
              | Some (_, String name) -> Stdlib.Result.Result.Ok name
              | Some (_, _) -> Stdlib.Result.Result.Error "name must be a string"
              | None -> Stdlib.Result.Result.Error "name is required"

            let argsResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "arguments") with
              | Some (_, args) -> Stdlib.Result.Result.Ok args
              | None -> Stdlib.Result.Result.Error "arguments is required"

            match (nameResult, argsResult) with
            | (Ok name, Ok args) ->
                Stdlib.Result.Result.Ok (CallToolParams { name = name; arguments = args })
            | (Error e, _) -> Stdlib.Result.Result.Error e
            | (_, Error e) -> Stdlib.Result.Result.Error e
          | _ ->
              Stdlib.Result.Result.Error "params must be an object"

        let toJson (params: CallToolParams) : Json =
          Json.Object [
            ("name", Json.String params.name);
            ("arguments", params.arguments)
          ]

      /// Response for calling a tool
      module CallToolResponse =
        // Content types that can be returned by tools
        type ContentItem =
          | TextContent of String
          // add support for images and embedded resources
          // | ImageContent
          // | EmbeddedResource

        type CallToolResponse =
          { content: List<ContentItem>
            isError: Stdlib.Option.Option<Bool> }

        let contentItemToJson (item: ContentItem) : Json =
          match item with
          | TextContent text ->
            Json.Object [
              ("type", Json.String "text");
              ("text", Json.String text)
            ]
          // add support for images and embedded resources

        let toJson (response: CallToolResponse.CallToolResponse) : Json =
          let contentJson = response.content |> Stdlib.List.map contentItemToJson

          let fields = [("content", Json.Array contentJson)]

          // Only include isError if it's true (indicating an actual error)
          let fieldsWithIsError =
            match response.isError with
            | Some true -> Stdlib.List.append fields [("isError", Json.Bool true)]
            | _ -> fields

          Json.Object fieldsWithIsError

      /// Response for listing tools
      module ListToolsResponse =
        type ListToolsResponse =
          { tools: List<ToolDescription> }

        module ToolAnnotations =
          let toJson (annotations: ToolAnnotations) : Json =
            let fields = []
            let fields =
              match annotations.title with
              | Some title -> Stdlib.List.append fields [("title", Json.String title)]
              | None -> fields
            let fields =
              match annotations.readOnlyHint with
              | Some hint -> Stdlib.List.append fields [("readOnlyHint", Json.Bool hint)]
              | None -> fields
            let fields =
              match annotations.destructiveHint with
              | Some hint -> Stdlib.List.append fields [("destructiveHint", Json.Bool hint)]
              | None -> fields
            let fields =
              match annotations.idempotentHint with
              | Some hint -> Stdlib.List.append fields [("idempotentHint", Json.Bool hint)]
              | None -> fields
            let fields =
              match annotations.openWorldHint with
              | Some hint -> Stdlib.List.append fields [("openWorldHint", Json.Bool hint)]
              | None -> fields
            Json.Object fields

        module ToolDescription =
          let toJson (tool: ToolDescription) : Json =
            let fields = [
              ("name", Json.String tool.name);
              ("inputSchema", tool.inputSchema)
            ]
            let fields =
              match tool.description with
              | Some desc -> Stdlib.List.append fields [("description", Json.String desc)]
              | None -> fields
            let fields =
              match tool.annotations with
              | Some annotations -> Stdlib.List.append fields [("annotations", ToolAnnotations.toJson annotations)]
              | None -> fields
            Json.Object fields

        let toJson (response: ListToolsResponse) : Json =
          let toolsJson = response.tools |> Stdlib.List.map ToolDescription.toJson
          Json.Object [
            ("tools", Json.Array toolsJson)
          ]

      /// Helper functions for working with tools
      module Helpers =
        /// Create a text content item
        let createTextContent (text: String) : CallToolResponse.ContentItem =
          CallToolResponse.ContentItem.TextContent text

        /// Create an error response
        let createErrorResponse (errorMessage: String) : CallToolResponse.CallToolResponse =
          CallToolResponse.CallToolResponse
            { content = [createTextContent errorMessage]
              isError = Stdlib.Option.Option.Some true }

        /// Create a success response
        let createSuccessResponse (content: List<CallToolResponse.ContentItem>) : CallToolResponse.CallToolResponse =
          CallToolResponse.CallToolResponse
            { content = content
              isError = Stdlib.Option.Option.None }