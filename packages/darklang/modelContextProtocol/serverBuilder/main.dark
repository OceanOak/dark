module Darklang.ModelContextProtocol.ServerBuilder

let create (name: String) (tools: List<ToolDefinition>) (resources: List<ResourceDefinition>) (prompts: List<PromptDefinition>) : McpServerBuilder =
  let toolsDict =
    tools
    |> Stdlib.List.map (fun toolDef -> (toolDef.description.name, toolDef))
    |> Stdlib.Dict.fromList
    |> Stdlib.Option.withDefault Stdlib.Dict.empty

  let resourcesDict =
    resources
    |> Stdlib.List.map (fun resourceDef -> (resourceDef.description.uri, resourceDef))
    |> Stdlib.Dict.fromList
    |> Stdlib.Option.withDefault Stdlib.Dict.empty

  let promptsDict =
    prompts
    |> Stdlib.List.map (fun promptDef -> (promptDef.description.name, promptDef))
    |> Stdlib.Dict.fromList
    |> Stdlib.Option.withDefault Stdlib.Dict.empty

  McpServerBuilder {
    name = name
    tools = toolsDict
    resources = resourcesDict
    prompts = promptsDict
  }


/// Main server loop to handle ongoing messages
let runServerCliLoop (state: State.BuilderServerState) : Int64 =
  logWithPath state.logFilePath "---"

  let incomingMessageRaw = readMessageFromClientWithPath state.logFilePath
  logIncomingRequestWithPath state.logFilePath incomingMessageRaw

  // Handle empty messages (client disconnected)
  if incomingMessageRaw == "" then
    logWithPath state.logFilePath "Received empty message, client disconnected"
    0L
  else
    let updatedState =
      // parse a json-rpc message from stdin, and call `handleIncomingMessage` on it when relevant
      match JsonRPC.IncomingMessage.parse incomingMessageRaw with
      // The json-rpc spec says to just ignore any incoming messages of `[]`
      | EmptyBatch ->
          logWithPath state.logFilePath "Received empty batch, continuing"
          state

      // # Things we want/expect
      | SingleRequest(Ok jsonRpcRequest) ->
          logWithPath state.logFilePath $"Parsed incoming message as single JSON-RPC request"
          handleIncomingMessage state jsonRpcRequest

      | BatchOfRequests items ->
          // Handle batch requests by processing each one in sequence
          let len = (Stdlib.List.length items) |> Stdlib.Int64.toString
          logWithPath state.logFilePath $"Got batch request with {len} items"

          let processedState =
            items
            |> Stdlib.List.fold state (fun acc item ->
              match item with
              | Ok request ->
                  handleIncomingMessage acc request
              | Error err ->
                  logWithPath state.logFilePath $"Error in batch request item: {err}"
                  acc
            )

          processedState

      // # Errors

      // was an object {} but not a valid json-rpc 2.0 _request_
      // (note: could have been a valid _response_ though - we don't yet have good support for that)
      | SingleRequest(Error singleRequestParseError) ->
          match singleRequestParseError with
          | NotObject json ->
              let error = Stdlib.AltJson.format json

              logWithPath state.logFilePath
                $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}\nError: it must be an object, but was: {error}"

              sendErrorResponseWithPath
                state.logFilePath
                Stdlib.Option.Option.None
                ModelContextProtocol.ErrorCodes.parseError
                "Parse error: Request must be an object"

              state

          | MissingJsonRpcField ->
              logWithPath state.logFilePath
                $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}\nError: it must have a 'jsonrpc' field"

              sendErrorResponseWithPath
                state.logFilePath
                Stdlib.Option.Option.None
                ModelContextProtocol.ErrorCodes.parseError
                "Parse error: Missing 'jsonrpc' field"

              state

          | InvalidIdField json ->
              let error = Stdlib.AltJson.format json

              logWithPath state.logFilePath
                $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}\nError: 'id' field must be Null, a Number or a String, but was: {error}"

              sendErrorResponseWithPath
                state.logFilePath
                Stdlib.Option.Option.None
                ModelContextProtocol.ErrorCodes.parseError
                "Parse error: Invalid 'id' field"

              state

          | MissingMethodField id ->
              logWithPath state.logFilePath
                $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}\nError: 'method' field must be provided"

              sendErrorResponseWithPath
                state.logFilePath
                id
                ModelContextProtocol.ErrorCodes.invalidRequest
                "Invalid request: Missing 'method' field"

              state

          | InvalidMethodField(id, actual) ->
              let error = Stdlib.AltJson.format actual

              logWithPath state.logFilePath
                $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}\nError: 'method' field must be a string, but was: {error}"

              sendErrorResponseWithPath
                state.logFilePath
                id
                ModelContextProtocol.ErrorCodes.invalidRequest
                "Invalid request: 'method' must be a string"

              state

          | InvalidParamsField(id, actual) ->
              let error = Stdlib.AltJson.format actual

              logWithPath state.logFilePath
                $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}\nError: 'params' field must be an Array or an Object, but was: {error}"

              sendErrorResponseWithPath
                state.logFilePath
                id
                ModelContextProtocol.ErrorCodes.invalidRequest
                "Invalid request: 'params' must be an array or object"

              state

          | _ ->
              logWithPath state.logFilePath
                $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}"

              sendErrorResponseWithPath
                state.logFilePath
                Stdlib.Option.Option.None
                ModelContextProtocol.ErrorCodes.parseError
                "Parse error"

              state

      | NotJson err ->
          logWithPath state.logFilePath
            $"Error parsing incoming message as json:\n{incomingMessageRaw}\nError: {err}"

          sendErrorResponseWithPath
            state.logFilePath
            Stdlib.Option.Option.None
            ModelContextProtocol.ErrorCodes.parseError
            "Parse error: Invalid JSON"

          state

      | NotObjectOrArray ->
          logWithPath state.logFilePath $"Error parsing incoming message as json-rpc:\n{incomingMessageRaw}"

          sendErrorResponseWithPath
            state.logFilePath
            Stdlib.Option.Option.None
            ModelContextProtocol.ErrorCodes.invalidRequest
            "Invalid Request: Must be an object or array"

          state

    // shut down if instructed, or listen for the next message
    if updatedState.shouldShutdown then
      logWithPath updatedState.logFilePath "Server shutting down"
      0L
    else
      runServerCliLoop updatedState


/// This is the main entrypoint for the Darklang MCP server.
///
/// It reads incoming messages from stdin, and writes responses to stdout,
/// following the MCP spec. It also logs all incoming and outgoing messages
/// to `rundir/logs/mcp-server.log`, for local debugging.
///
/// The server provides access to:
/// - Darklang code execution and type checking
/// - Package management and discovery
/// - Function search and documentation
/// - Code review and refactoring assistance
/// - Testing utilities
let run (server: McpServerBuilder) : Int64 =
  // Get server-specific log file path
  let logFilePath = getLogFilePath server.name

  // clear log file and write a timestamp of the start-up
  let _deleted = Builtin.fileDelete logFilePath

  (Stdlib.DateTime.now_v0 ())
  |> Stdlib.DateTime.toString
  |> fun nowStr -> logWithPath logFilePath $"Running {server.name} MCP Server {nowStr}"

  let toolCount = (Stdlib.Dict.size server.tools) |> Stdlib.Int64.toString
  let resourceCount = (Stdlib.Dict.size server.resources) |> Stdlib.Int64.toString
  let promptCount = (Stdlib.Dict.size server.prompts) |> Stdlib.Int64.toString

  logWithPath logFilePath $"Server '{server.name}' features:"
  logWithPath logFilePath $"  - Tools: {toolCount} registered"
  logWithPath logFilePath $"  - Resources: {resourceCount} registered"
  logWithPath logFilePath $"  - Prompts: {promptCount} registered"
  logWithPath logFilePath "  - Protocol version: 2025-06-18"

  // The first thing we get is the `initialize` request,
  // where the client tells us what capabilities it has,
  // and we tell the client what capabilities we have,
  // so the client knows which requests it can make.
  let initializeReq = readMessageFromClientWithPath logFilePath
  logIncomingRequestWithPath logFilePath initializeReq

  // Parse and handle the initialize request
  let initialState =
    match JsonRPC.IncomingMessage.parse initializeReq with
    | SingleRequest(Ok jsonRpcRequest) ->
        match ModelContextProtocol.parseIncomingMessage jsonRpcRequest with
        | InitializeRequest(requestId, params) ->
            handleInitializeRequest server logFilePath requestId params
        | _ ->
            logWithPath logFilePath "First message must be initialize request"
            State.BuilderServerState {
              initialized = false
              shouldShutdown = false
              server = server
              traceLevel = TraceLevel.Off
              loggingLevel = LoggingLevel.Info
              logFilePath = logFilePath
              resourceTemplates = Stdlib.Dict.empty
              roots = []
            }
    | _ ->
        logWithPath logFilePath "Failed to parse initialize request"
        State.BuilderServerState {
          initialized = false
          shouldShutdown = false
          server = server
          traceLevel = TraceLevel.Off
          loggingLevel = LoggingLevel.Info
          logFilePath = logFilePath
          resourceTemplates = Stdlib.Dict.empty
          roots = []
        }

  // now that initialization is complete, we can start responding to normal requests
  runServerCliLoop initialState