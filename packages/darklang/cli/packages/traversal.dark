module Darklang.Cli.Packages.Traversal

// Path segment type for navigation
type PathSegment =
  | Root           // Go to root (/)
  | Here           // Stay here (.)
  | Up             // Go up one level (..)
  | Into of String // Go into a named entity/module

let parsePath (pathStr: String) : List<PathSegment> =
  if pathStr == "/" then
    [PathSegment.Root]
  else
    // Check if path ends with a dot - this means user wants to complete within that location
    let endsWithDot = Stdlib.String.endsWith pathStr "."

    // Split on / first, then handle each part separately
    let parts =
      pathStr
      |> Stdlib.String.split "/"
      |> Stdlib.List.map (fun part ->
        // Don't split ".." on dots - it's a special case
        if part == ".." then
          [part]
        else
          Stdlib.String.split part "."
      )
      |> Stdlib.List.flatten
      |> Stdlib.List.filter (fun p -> Stdlib.Bool.not (Stdlib.String.isEmpty p))

    // If path ended with dot, add empty string to indicate completion at that level
    let finalParts = if endsWithDot then Stdlib.List.append parts [""] else parts

    let segments =
      finalParts
      |> Stdlib.List.map (fun part ->
        match part with
        | "." -> PathSegment.Here
        | ".." -> PathSegment.Up
        | name -> PathSegment.Into name
      )

    if Stdlib.String.startsWith pathStr "/" then
      // Absolute path from root
      Stdlib.List.append [PathSegment.Root] segments
    else
      segments


let getCurrentModulePath (location: PackageLocation) : List<String> =
  match location with
  | Module path -> path
  | Type t -> Stdlib.List.append [t.owner] t.modules
  | Value v -> Stdlib.List.append [v.owner] v.modules
  | Function f -> Stdlib.List.append [f.owner] f.modules


let applySegment (location: PackageLocation) (segment: PathSegment) : Stdlib.Result.Result<PackageLocation, String> =
  match segment with
  | Root ->
    Stdlib.Result.Result.Ok (PackageLocation.Module [])

  | Here ->
    Stdlib.Result.Result.Ok location

  | Up ->
    match location with
    | Module [] ->
      Stdlib.Result.Result.Error "Already at root - cannot go to parent"
    | Module modules ->
      let newModules = Stdlib.List.dropLast modules
      Stdlib.Result.Result.Ok (PackageLocation.Module newModules)
    | Type name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)
    | Value name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)
    | Function name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)

  | Into name ->
    let currentPath = getCurrentModulePath location
    resolveEntity currentPath name


// Resolve a name to an actual entity (module, type, fn, or value)
let resolveEntity (basePath: List<String>) (name: String) : Stdlib.Result.Result<PackageLocation, String> =
  // First see if it's a module
  let modulePath = Stdlib.List.append basePath [name]
  let moduleResults = Search.searchContents modulePath

  let isAModule = Search.hasContent moduleResults

  if isAModule then
    Stdlib.Result.Result.Ok (PackageLocation.Module modulePath)
  // Not a module -- check if it's a type/value/fn
  else
    let entityResults = Search.searchEntity basePath name

    // Look for exact matches
    let matchingType = Search.findTypeByName entityResults name
    let matchingValue = Search.findValueByName entityResults name
    let matchingFn = Search.findFnByName entityResults name

    match matchingType with
    | Some t -> Stdlib.Result.Result.Ok (PackageLocation.Type t.name)
    | None ->
      match matchingFn with
      | Some f -> Stdlib.Result.Result.Ok (PackageLocation.Function f.name)
      | None ->
        match matchingValue with
        | Some v -> Stdlib.Result.Result.Ok (PackageLocation.Value v.name)
        | None -> Stdlib.Result.Result.Error "Not found"


let applyPath (start: PackageLocation) (segments: List<PathSegment>) : Stdlib.Result.Result<PackageLocation, String> =
  segments
  |> Stdlib.List.fold (Stdlib.Result.Result.Ok start) (fun accResult segment ->
    match accResult with
    | Error e -> Stdlib.Result.Result.Error e
    | Ok loc -> applySegment loc segment
  )


// Search for module names under Darklang owner (fallback search)
let searchDarklangModules (prefixText: String) : List<String> =
  let darklangResults = Search.searchContents ["Darklang"]
  let currentPathLength = 1L
  let moduleNames = Search.getDirectSubmodules darklangResults currentPathLength

  moduleNames
  |> Stdlib.List.filter (fun name -> Stdlib.String.startsWith name prefixText)
  |> Stdlib.List.map (fun name -> "Darklang." ++ name) // Return fully qualified names

// Get all available names at a location for completion
let getAvailableNames (location: PackageLocation) (prefixText: String) : List<String> =
  let currentPath = getCurrentModulePath location
  // Get all available entities in this module
  let allResults = Search.searchContents currentPath

  let currentPathLength = Stdlib.List.length currentPath
  let moduleNames = Search.getDirectSubmodules allResults currentPathLength
  let typeNames = allResults.types |> Stdlib.List.map (fun t -> t.name.name)
  let fnNames = allResults.fns |> Stdlib.List.map (fun f -> f.name.name)
  let valueNames = allResults.values |> Stdlib.List.map (fun v -> v.name.name)

  let allNames =
    moduleNames
    |> Stdlib.List.append typeNames
    |> Stdlib.List.append fnNames
    |> Stdlib.List.append valueNames
    |> Stdlib.List.unique
    |> Stdlib.List.sort

  // Primary results: filter by prefix if we have search text
  let primaryResults =
    if Stdlib.String.isEmpty prefixText then
      allNames
    else
      allNames |> Stdlib.List.filter (fun name -> Stdlib.String.startsWith name prefixText)

  // At root level: prioritize owners, then add fallback
  match location with
  | Module [] when Stdlib.Bool.not (Stdlib.String.isEmpty prefixText) ->
    let ownerMatches = primaryResults |> Stdlib.List.filter (fun result -> Stdlib.Bool.not (Stdlib.String.contains result "."))

    if Stdlib.Bool.not (Stdlib.List.isEmpty ownerMatches) then
      ownerMatches
    else
      let fallbackResults = searchDarklangModules prefixText
      primaryResults |> Stdlib.List.append fallbackResults |> Stdlib.List.unique |> Stdlib.List.sort
  | _ ->
    primaryResults

// Simple completion: traverse exact path, then fuzzy search the last part
let completePartialPath (start: PackageLocation) (partialPath: String) : List<String> =
  let segments = parsePath partialPath


  match Stdlib.List.reverse segments with
  | [] ->
    // Empty path - get completions from current location
    getAvailableNames start ""

  | (Into fuzzyPart) :: exactSegmentsReversed ->
    // Navigate to exact path, then fuzzy search
    let exactSegments = Stdlib.List.reverse exactSegmentsReversed
    match applyPath start exactSegments with
    | Error _ -> []
    | Ok contextLocation ->
      let completionNames = getAvailableNames contextLocation fuzzyPart

      // Build prefix for the completions, preserving the separator style
      let prefix =
        if Stdlib.List.isEmpty exactSegments then
          ""
        else
          // Check if original path uses / separator
          let usesSlash = Stdlib.String.contains partialPath "/"
          let separator = if usesSlash then "/" else "."

          let pathStr =
            exactSegments
            |> Stdlib.List.map (fun segment ->
              match segment with
              | Root -> ""
              | Here -> "."
              | Up -> ".."
              | Into name -> name
            )
            |> Stdlib.List.filter (fun s -> Stdlib.Bool.not (Stdlib.String.isEmpty s))
            |> Stdlib.String.join separator
          pathStr ++ separator

      completionNames |> Stdlib.List.map (fun name -> prefix ++ name)

  | _ ->
    // Last segment is Root, Here, or Up - no fuzzy completion
    []


// Main traverse function
let traverse (start: PackageLocation) (path: String) : Stdlib.Result.Result<PackageLocation, String> =
  let segments = parsePath path
  applyPath start segments
