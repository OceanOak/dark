module Darklang =
  module Cli =
    module CommandHelpers =
      module View =
        /// Converts an EntityCategory to its string representation
        let entityCategoryToString (category: EntityCategory) : String =
          match category with
          | Functions -> "functions"
          | Types -> "types"
          | Constants -> "constants"
          | Submodules -> "submodules"

        /// Converts a category index to an EntityCategory
        let indexToEntityCategory (index: Int64) : EntityCategory =
          match index with
          | 0L -> EntityCategory.Functions
          | 1L -> EntityCategory.Types
          | 2L -> EntityCategory.Constants
          | 3L -> EntityCategory.Submodules
          | _ -> EntityCategory.Functions  // Default fallback

        /// Converts an EntityCategory to its index
        let entityCategoryToIndex (category: EntityCategory) : Int64 =
          match category with
          | Functions -> 0L
          | Types -> 1L
          | Constants -> 2L
          | Submodules -> 3L

        module Rendering =

          /// Renders view content based on type
          let renderView (content: ViewContent) : String =
            match content with
            | ModuleView (category, items, selectedIndex) ->
              let formattedItems =
                items
                |> Stdlib.List.indexedMap (fun index item ->
                  if index == selectedIndex then
                    $"{CliColors.magenta}[{item}]{CliColors.reset}"
                  else
                    item)
              if Stdlib.List.isEmpty formattedItems then "(none)" else Stdlib.String.join formattedItems ", "

            | EntityDefinitionView entityDef ->
              // Calculate actual display lines accounting for wrapping
              let terminalWidth = Terminal.getWidth ()
              let displayLinesInfo =
                entityDef.lines
                |> Stdlib.List.map (fun line ->
                  (line, Terminal.calculateWrappedLineCount line terminalWidth))

              let totalDisplayLines =
                displayLinesInfo
                |> Stdlib.List.fold 0L (fun acc (_, count) -> acc + count)

              let viewportHeight = Terminal.getContentViewportHeight totalDisplayLines
              let safeViewportHeight = Stdlib.Int64.max 1L viewportHeight

              // Calculate scroll position in terms of display lines
              let maxScrollPos =
                if totalDisplayLines <= safeViewportHeight then
                  0L
                else
                  totalDisplayLines - safeViewportHeight

              let adjustedScrollPos =
                entityDef.scrollPosition
                |> Stdlib.Int64.max 0L
                |> Stdlib.Int64.min maxScrollPos

              // Find which logical lines to show based on display line scroll position
              let visibleLines =
                displayLinesInfo
                |> Stdlib.List.fold ([], (0L, adjustedScrollPos, safeViewportHeight))
                  (fun acc lineInfo ->
                    let (accLines, state) = acc
                    let (currentDisplayLine, skipLines, remainingViewport) = state
                    let (line, wrappedCount) = lineInfo

                    if remainingViewport <= 0L then
                      // Viewport is full
                      (accLines, (currentDisplayLine + wrappedCount, skipLines, remainingViewport))
                    else if skipLines >= wrappedCount then
                      // Skip this entire logical line
                      (accLines, (currentDisplayLine + wrappedCount, skipLines - wrappedCount, remainingViewport))
                    else if skipLines > 0L then
                      // Partially skip this line (edge case for wrapped lines)
                      let displayCount = Stdlib.Int64.min wrappedCount remainingViewport
                      (Stdlib.List.push accLines line, (currentDisplayLine + wrappedCount, 0L, remainingViewport - displayCount))
                    else
                      // Include this line
                      let displayCount = Stdlib.Int64.min wrappedCount remainingViewport
                      (Stdlib.List.push accLines line, (currentDisplayLine + wrappedCount, 0L, remainingViewport - displayCount))
                  )
                |> fun result ->
                  let (lines, _) = result
                  lines |> Stdlib.List.reverse

              $"{CliColors.blue}{entityDef.name}\n\n" ++ (visibleLines |> Stdlib.String.join "\n")

          /// Wraps the content with a help bar for module viewing
          let renderModuleViewingInterface (content: String) : String =
            let helpBar = $"{CliColors.gray}↑/↓: categories  ←/→: entities  Enter: expand/view  b: back  q: quit{CliColors.reset}\n\n"
            $"{Terminal.Display.clearScreen}{content}\n{helpBar}"

          /// Wraps the content with a help bar for entity definition viewing
          let renderEntityViewingInterface (content: String) : String =
            let helpBar = $"{CliColors.gray}↑/↓: scroll  ←/→: page  Enter: collapse  b: back  q: quit{CliColors.reset}\n\n"
            $"{Terminal.Display.clearScreen}{content}\n{helpBar}"


          /// Renders entity interface with scrolling
          let renderEntityInterface (entityName: String) (lines: List<String>) (scrollPosition: Int64) : String =
            let entityDef = EntityDefinition { name = entityName; lines = lines; scrollPosition = scrollPosition }
            let content = ViewContent.EntityDefinitionView entityDef
            let visibleContent = renderView content
            renderEntityViewingInterface visibleContent

          /// Formats a section of entities for display with expandable state and scrolling
          let formatEntitySection (viewingState: ViewingState) (category: EntityCategory) (entities: List<String>) : String =
            let sectionName = View.entityCategoryToString category
            let isExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 category

            let expandIndicator = if isExpanded then $"{CliColors.purple}▼{CliColors.reset}" else $"{CliColors.purple}▶{CliColors.reset}"
            let selectionIndicator = if viewingState.selectedCategory == category then "→ " else "  "
            let header = $"{selectionIndicator}{expandIndicator} {sectionName} {CliColors.gray}({entities |> Stdlib.List.length |> Stdlib.Int64.toString}){CliColors.reset}"

            if Stdlib.List.isEmpty entities then
              $"{header}\n\n(none)\n"
            else if isExpanded then
              // Extract just the names without module prefixes
              let shortNames =
                entities
                |> Stdlib.List.map (fun fullName ->
                  fullName
                  |> Stdlib.String.split "."
                  |> Stdlib.List.last
                  |> Stdlib.Option.withDefault fullName)

              if viewingState.selectedCategory == category && viewingState.selectedItemIndex >= 0L then
                let content = ViewContent.ModuleView (category, shortNames, viewingState.selectedItemIndex)
                let itemsDisplay = renderView content
                $"{header}\n\n{itemsDisplay}\n"
              else
                $"{header}\n\n" ++ (Stdlib.String.join shortNames ", ") ++ "\n"
            else
              $"{header}\n"

          /// Formats a section of entities for display with simple list (for non-interactive mode)
          let formatEntitySectionSimple (sectionName: String) (entities: List<String>) : String =
            if Stdlib.List.isEmpty entities then
              $"{sectionName}:\n\n(none)\n"
            else
              $"{sectionName}:\n\n" ++ (Stdlib.String.join entities "\n") ++ "\n"

          /// Formats module content for non-interactive display
          let formatModuleContentSimple (moduleContent: LanguageTools.ProgramTypes.Search.SearchResults) : String =
            let functionsSection =
              formatEntitySectionSimple
                "functions"
                (moduleContent.fns
                  |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name))

            let typesSection =
              formatEntitySectionSimple
                "types"
                (moduleContent.types
                  |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name))

            let constantsSection =
              formatEntitySectionSimple
                "constants"
                (moduleContent.constants
                  |> Stdlib.List.map (fun c -> LanguageTools.ProgramTypes.PackageConstant.nameToString c.name))

            let submodulesSection =
              formatEntitySectionSimple
                "submodules"
                (moduleContent.submodules
                  |> Stdlib.List.map (fun m ->
                    m
                    |> Stdlib.List.map (fun s -> s |> Stdlib.String.join "."))
                  |> Stdlib.List.flatten)

            functionsSection ++
            typesSection ++
            constantsSection ++
            submodulesSection

          /// Formats module content for interactive display
          let formatModuleContent (viewingState: ViewingState) : String =
            let functionsSection =
              formatEntitySection
                viewingState
                EntityCategory.Functions
                (viewingState.moduleContent.fns
                  |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name))

            let typesSection =
              formatEntitySection
                viewingState
                EntityCategory.Types
                (viewingState.moduleContent.types
                  |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name))

            let constantsSection =
              formatEntitySection
                viewingState
                EntityCategory.Constants
                (viewingState.moduleContent.constants
                  |> Stdlib.List.map (fun c -> LanguageTools.ProgramTypes.PackageConstant.nameToString c.name))

            let submodulesSection =
              formatEntitySection
                viewingState
                EntityCategory.Submodules
                (viewingState.moduleContent.submodules
                  |> Stdlib.List.map (fun m ->
                    m
                    |> Stdlib.List.map (fun singleModulePath ->
                      Stdlib.String.join singleModulePath "."))
                  |> Stdlib.List.flatten
                  |> Stdlib.List.filter (fun submodule ->
                    submodule != viewingState.entityName))

            let moduleHeader = $"{CliColors.blue}Module: {viewingState.entityName}{CliColors.reset}\n"

            // Scrollable content (everything below the module title)
            let scrollableContent =
              "\n" ++
              functionsSection ++ "\n" ++
              typesSection ++ "\n" ++
              constantsSection ++ "\n" ++
              submodulesSection

            // Apply viewport scrolling only to the scrollable content
            let scrollableLines = scrollableContent |> Stdlib.String.split "\n"
            let totalScrollableLines = scrollableLines |> Stdlib.List.length
            let viewportHeight = Terminal.getModuleViewportHeight ()

            // Reserve space for the module header (1 line)
            let availableScrollHeight = Stdlib.Int64.max 1L (viewportHeight - 1L)

            // Ensure scroll position is within bounds
            let maxScrollPos = Stdlib.Int64.max 0L (totalScrollableLines - availableScrollHeight)
            let adjustedScrollPos =
              viewingState.viewportScrollPosition
              |> Stdlib.Int64.max 0L
              |> Stdlib.Int64.min maxScrollPos

            let visibleScrollableLines =
              scrollableLines
              |> Stdlib.List.drop adjustedScrollPos
              |> Stdlib.List.take availableScrollHeight

            // Combine fixed header with scrollable content
            moduleHeader ++ (visibleScrollableLines |> Stdlib.String.join "\n")

        module Navigation =
          type ScrollDirection = Up | Down | PageUp | PageDown

          /// Helper function to handle module viewport scrolling
          let handleModuleViewportScroll (state: State) (direction: ScrollDirection) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              let viewportHeight = Terminal.getModuleViewportHeight ()

              let newScrollPos =
                match direction with
                | Up -> Stdlib.Int64.max 0L (viewingState.viewportScrollPosition - 1L)
                | Down -> viewingState.viewportScrollPosition + 1L // Will be bounded in formatModuleContent
                | PageUp -> Stdlib.Int64.max 0L (viewingState.viewportScrollPosition - viewportHeight)
                | PageDown -> viewingState.viewportScrollPosition + viewportHeight // Will be bounded in formatModuleContent

              let newViewingState = { viewingState with viewportScrollPosition = newScrollPos }
              let moduleView = Rendering.formatModuleContent newViewingState
              let completeInterface = Rendering.renderModuleViewingInterface moduleView
              let newState =
                { state with
                    viewingState = Stdlib.Option.Option.Some newViewingState
                    commandResult = CommandResult.Success completeInterface
                    needsFullRedraw = true }
              (newState, [])
            | None ->
              (state, [])

          /// Helper function to handle entity definition scrolling
          let handleEntityScroll (state: State) (direction: ScrollDirection) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              match viewingState.entityDefinition with
              | Some entityDef ->
                let terminalWidth = Terminal.getWidth ()
                let totalDisplayLines =
                  entityDef.lines
                  |> Stdlib.List.fold 0L (fun acc line ->
                    acc + Terminal.calculateWrappedLineCount line terminalWidth)

                let contentHeight = Terminal.getContentViewportHeight totalDisplayLines
                let maxScroll = Stdlib.Int64.max 0L (totalDisplayLines - contentHeight)

                let scrollAmount =
                  match direction with
                  | PageUp | PageDown -> contentHeight
                  | _ -> 1L

                let newScrollPos =
                  match direction with
                    | Up -> Stdlib.Int64.max 0L (entityDef.scrollPosition - scrollAmount)
                    | Down -> Stdlib.Int64.min maxScroll (entityDef.scrollPosition + scrollAmount)
                    | PageUp -> Stdlib.Int64.max 0L (entityDef.scrollPosition - scrollAmount)
                    | PageDown -> Stdlib.Int64.min maxScroll (entityDef.scrollPosition + scrollAmount)

                let newEntityDef = { entityDef with scrollPosition = newScrollPos }
                let completeInterface = Rendering.renderEntityInterface newEntityDef.name newEntityDef.lines newEntityDef.scrollPosition
                let newViewingState = { viewingState with entityDefinition = Stdlib.Option.Option.Some newEntityDef }
                let newState =
                  { state with
                      viewingState = Stdlib.Option.Option.Some newViewingState
                      commandResult = CommandResult.Success completeInterface
                      needsFullRedraw = true }
                (newState, [])
              | None ->
                (state, [])
            | None ->
              (state, [])

          /// Calculate the line position of a category header in the scrollable content
          let calculateCategoryLinePosition (viewingState: ViewingState) (targetCategory: EntityCategory) : Int64 =
            let blankLineAfterModuleTitle = 1L // blank line after "Module: X"
            let targetIndex = View.entityCategoryToIndex targetCategory

            // Count lines for each category before the target
            let categories = [EntityCategory.Functions; EntityCategory.Types; EntityCategory.Constants; EntityCategory.Submodules]

            let linesBeforeTarget =
              categories
              |> Stdlib.List.take targetIndex
              |> Stdlib.List.fold 0L (fun acc category ->
                let entities = EntityLookup.getEntitiesForCategory viewingState.moduleContent category viewingState.entityName
                let isExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 category

                let headerLine = 1L
                let contentLines =
                  if Stdlib.List.isEmpty entities then
                    2L // blank line + "(none)" + blank line
                  else if isExpanded then
                    3L // blank line + content + blank line
                  else
                    1L // blank line after header

                acc + headerLine + contentLines
              )

            blankLineAfterModuleTitle + linesBeforeTarget

          /// Helper function to ensure a category is visible in the scrollable viewport area
          let ensureCategoryVisible (viewingState: ViewingState) (category: EntityCategory) : Int64 =
            let categoryLine = calculateCategoryLinePosition viewingState category
            let viewportHeight = Terminal.getModuleViewportHeight ()
            let availableScrollHeight = Stdlib.Int64.max 1L (viewportHeight - 1L)
            let currentScrollPos = viewingState.viewportScrollPosition
            let viewportTop = currentScrollPos
            let viewportBottom = currentScrollPos + availableScrollHeight - 1L

            if categoryLine < viewportTop then
              // Category is above viewport, scroll up to show it at the top
              Stdlib.Int64.max 0L categoryLine
            else if categoryLine > viewportBottom then
              // Category is below viewport, scroll down to show it near the top
              Stdlib.Int64.max 0L (categoryLine - 2L) // Show category header 2 lines from top
            else if categoryLine > (viewportTop + (availableScrollHeight |> Stdlib.Int64.divide 2L)) then
              // Category is in lower half, move it to upper half for better visibility
              Stdlib.Int64.max 0L (categoryLine - 2L)
            else
              // Category is already visible in upper half, keep current position
              currentScrollPos

          /// Helper function to update selection and redraw view with auto-scroll to keep selection visible
          let updateSelection (state: State) (category: EntityCategory) (itemIndex: Int64) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              // If switching to a different category, collapse all. If staying in same category, preserve expanded state
              let newExpandedCategories =
                if category == viewingState.selectedCategory then
                  viewingState.expandedCategories  // Keep current expanded state when navigating within category
                else
                  []  // Collapse when switching categories

              let tempViewingState = { viewingState with selectedCategory = category; selectedItemIndex = itemIndex; expandedCategories = newExpandedCategories }
              let newScrollPosition = ensureCategoryVisible tempViewingState category

              let newViewingState = { tempViewingState with entityDefinition = Stdlib.Option.Option.None; viewportScrollPosition = newScrollPosition }
              let moduleView = Rendering.formatModuleContent newViewingState
              let completeInterface = Rendering.renderModuleViewingInterface moduleView
              let newState = { state with viewingState = Stdlib.Option.Option.Some newViewingState; commandResult = CommandResult.Success completeInterface; needsFullRedraw = true }
              (newState, [])
            | None ->
              (state, [])

          /// Handle key presses in viewing mode
          let handleViewingModeKey (state: State) (viewingState: ViewingState) (key: Stdlib.Cli.Stdin.Key.Key) (modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers) : (State * List<Msg>) =
            // Check for viewport scrolling (Ctrl+Arrow or Shift+Arrow for mouse wheel)
            match (key, modifiers.shift, modifiers.ctrl) with
            | (UpArrow, _, true) | (UpArrow, true, false) ->
              match viewingState.entityDefinition with
              | Some _ -> handleEntityScroll state ScrollDirection.Up
              | None -> handleModuleViewportScroll state ScrollDirection.Up
            | (DownArrow, _, true) | (DownArrow, true, false) ->
              match viewingState.entityDefinition with
              | Some _ -> handleEntityScroll state ScrollDirection.Down
              | None -> handleModuleViewportScroll state ScrollDirection.Down
            | _ ->
              match key with
              | UpArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.Up
                | None ->
                  let currentIndex = View.entityCategoryToIndex viewingState.selectedCategory
                  let newIndex = Stdlib.Int64.max 0L (currentIndex - 1L)
                  let newCategory = View.indexToEntityCategory newIndex
                  updateSelection state newCategory (-1L)
              | DownArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.Down
                | None ->
                  let currentIndex = View.entityCategoryToIndex viewingState.selectedCategory
                  let newIndex = Stdlib.Int64.min 3L (currentIndex + 1L)
                  let newCategory = View.indexToEntityCategory newIndex
                  updateSelection state newCategory (-1L)
              | Enter ->
                let isExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 viewingState.selectedCategory
                if isExpanded && viewingState.selectedItemIndex >= 0L then
                  (state, [Msg.ShowItemDefinition viewingState.selectedCategory viewingState.selectedItemIndex])
                else
                  (state, [Msg.ToggleCategory viewingState.selectedCategory])
              | LeftArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageUp
                | None ->
                  let currentExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 viewingState.selectedCategory
                  if currentExpanded then
                    let currentEntities = EntityLookup.getEntitiesForCategory viewingState.moduleContent viewingState.selectedCategory viewingState.entityName
                    let newItemIndex = Stdlib.Int64.max (-1L) (viewingState.selectedItemIndex - 1L)
                    updateSelection state viewingState.selectedCategory newItemIndex
                  else
                    (state, [])
              | RightArrow ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageDown
                | None ->
                  let currentExpanded = viewingState.expandedCategories |> Stdlib.List.member_v0 viewingState.selectedCategory
                  if currentExpanded then
                    let currentEntities = EntityLookup.getEntitiesForCategory viewingState.moduleContent viewingState.selectedCategory viewingState.entityName
                    let maxIndex = (currentEntities |> Stdlib.List.length) - 1L
                    let newItemIndex = Stdlib.Int64.min maxIndex (viewingState.selectedItemIndex + 1L)
                    updateSelection state viewingState.selectedCategory newItemIndex
                  else
                    (state, [])
              | B ->
                match viewingState.entityDefinition with
                | Some _ ->
                  let newViewingState = { viewingState with entityDefinition = Stdlib.Option.Option.None }
                  let moduleView = Rendering.formatModuleContent newViewingState
                  let completeInterface = Rendering.renderModuleViewingInterface moduleView
                  let newState =
                    { state with
                        viewingState = Stdlib.Option.Option.Some newViewingState
                        commandResult = CommandResult.Success completeInterface
                        needsFullRedraw = true }
                  (newState, [])
                | None ->
                  if viewingState.entityName |> Stdlib.String.contains "." then
                    let parts = viewingState.entityName |> Stdlib.String.split "."
                    let parentParts = parts |> Stdlib.List.dropLast
                    match parentParts with
                    | [] ->
                      (state, [])
                    | _ ->
                      let parentModule = Stdlib.String.join parentParts "."
                      (state, [Msg.SubmitCommand $"view {parentModule}"])
                  else
                    (state, [])
              | PageUp ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageUp
                | None ->
                  handleModuleViewportScroll state ScrollDirection.PageUp
              | PageDown ->
                match viewingState.entityDefinition with
                | Some _ ->
                  handleEntityScroll state ScrollDirection.PageDown
                | None ->
                  handleModuleViewportScroll state ScrollDirection.PageDown
              | Q ->
                let exitAlternateScreen = Terminal.Display.exitAltScreen
                let newState =
                  { state with
                      viewingState = Stdlib.Option.Option.None
                      commandResult = CommandResult.Success (exitAlternateScreen ++ "Exited viewing mode")
                      needsFullRedraw = true }
                (newState, [])
              | _ ->
                (state, [])

        module EntityLookup =
          /// Helper function to render entity definition
          let renderEntityDefinition (state: State) (entityType: String) (fullyQualifiedName: String) (prettyPrinted: String) : (State * List<Msg>) =
            match state.viewingState with
            | Some viewingState ->
              let (entityDefinition, updatedViewingState) = getOrCreateEntityDefinition viewingState entityType fullyQualifiedName prettyPrinted
              let completeInterface = Rendering.renderEntityInterface entityDefinition.name entityDefinition.lines entityDefinition.scrollPosition
              let finalViewingState = { updatedViewingState with entityDefinition = Stdlib.Option.Option.Some entityDefinition }
              let newState =
                { state with
                    commandResult = CommandResult.Success completeInterface
                    viewingState = Stdlib.Option.Option.Some finalViewingState
                    needsFullRedraw = true }
              (newState, [])
            | None ->
              let highlighted = Cli.SyntaxHighlighting.highlightCode prettyPrinted
              let newState =
                { state with
                    commandResult = CommandResult.Success $"{entityType}: {fullyQualifiedName}\n\n{highlighted}" }
              (newState, [])

          /// Helper function to view an entity by its fully qualified name
          let viewEntityByName (state: State) (fullyQualifiedName: String) : (State * List<Msg>) =
            let modules = fullyQualifiedName |> Stdlib.String.split "." |> Stdlib.List.dropLast
            let text = fullyQualifiedName |> Stdlib.String.split "." |> Stdlib.List.last |> Builtin.unwrap

            let query = Command.createSearchQuery modules text
            let moduleContent = LanguageTools.PackageManager.Search.search query

            match findEntity moduleContent text with
            | Some ((entityType, prettyPrinted)) ->
              renderEntityDefinition state entityType fullyQualifiedName prettyPrinted
            | None ->
              let newState =
                { state with
                    commandResult = CommandResult.Error $"Entity not found: {fullyQualifiedName}" }
              (newState, [])

          /// Entity lookup that finds an entity by name and returns its type and pretty-printed definition
          let findEntity (moduleContent: LanguageTools.ProgramTypes.Search.SearchResults) (name: String) : Stdlib.Option.Option<(String * String)> =
            let constantResult =
              moduleContent.constants
              |> Stdlib.List.findFirst (fun c -> c.name.name == name)
              |> Stdlib.Option.map (fun c -> ("Constant", PrettyPrinter.ProgramTypes.packageConstant c))

            let functionResult =
              moduleContent.fns
              |> Stdlib.List.findFirst (fun f -> f.name.name == name)
              |> Stdlib.Option.map (fun f -> ("Function", PrettyPrinter.ProgramTypes.packageFn f))

            let typeResult =
              moduleContent.types
              |> Stdlib.List.findFirst (fun t -> t.name.name == name)
              |> Stdlib.Option.map (fun t -> ("Type", PrettyPrinter.ProgramTypes.packageType t))

            match constantResult with
            | Some _ -> constantResult
            | None ->
              match functionResult with
              | Some _ -> functionResult
              | None -> typeResult

          /// Gets entities from moduleContent for a given category
          let getEntitiesForCategory (moduleContent: LanguageTools.ProgramTypes.Search.SearchResults) (category: EntityCategory) (currentEntityName: String) : List<String> =
            match category with
            | Functions -> moduleContent.fns |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)
            | Types -> moduleContent.types |> Stdlib.List.map (fun typ -> LanguageTools.ProgramTypes.PackageType.nameToString typ.name)
            | Constants -> moduleContent.constants |> Stdlib.List.map (fun constant -> LanguageTools.ProgramTypes.PackageConstant.nameToString constant.name)
            | Submodules ->
              moduleContent.submodules
              |> Stdlib.List.map (fun m ->
                m
                |> Stdlib.List.map (fun singleModulePath ->
                  Stdlib.String.join singleModulePath "."))
              |> Stdlib.List.flatten
              |> Stdlib.List.filter (fun submodule ->
                submodule != currentEntityName)

          /// Gets an entity definition from cache or creates a new one
          let getOrCreateEntityDefinition (viewingState: ViewingState) (entityType: String) (fullyQualifiedName: String) (prettyPrinted: String) : (EntityDefinition * ViewingState) =
            let cacheKey = $"{entityType}:{fullyQualifiedName}"

            match viewingState.entityCache |> Stdlib.List.findFirst (fun (key, _) -> key == cacheKey) with
            | Some ((_, cachedDef)) ->
              // Always reset scroll position to 0 when viewing an entity definition
              let resetDef = { cachedDef with scrollPosition = 0L }
              (resetDef, viewingState)
            | None ->
              // Create new definition and add to cache
              let highlighted = Cli.SyntaxHighlighting.highlightCode prettyPrinted
              let lines = highlighted |> Stdlib.String.split "\n"
              let entityDefinition = EntityDefinition { name = $"{entityType}: {fullyQualifiedName}"; lines = lines; scrollPosition = 0L }
              let newCache = viewingState.entityCache |> Stdlib.List.push (cacheKey, entityDefinition)
              let newViewingState = { viewingState with entityCache = newCache }
              (entityDefinition, newViewingState)