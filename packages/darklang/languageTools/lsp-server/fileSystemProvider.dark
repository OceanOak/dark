module Darklang =
  module LanguageTools =
    module LspServer =
      module FileSystemProvider =
        module ReadFile =
          let sendResponse
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (content: String)
            : LspState =
            let responseJson =
              (LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.ReadFileResponse
                { content = content })
              |> LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.toJson
              |> (fun r ->
                JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some(requestId)) r)
              |> Stdlib.AltJson.format

            logAndSendToClient responseJson
            state


          let handleReadFileRequest
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (params:
              LspExtension.FileSystemProvider.ReadFile.ReadFileParams.ReadFileParams)
            : LspState =
            // CLEANUP: make the 'remove scheme part of URI' more universal. Maybe be add it to Stdlib eg.`Stdlib.Uri.removeScheme`
            let nameForLookup =
              params.uri
              |> Stdlib.String.dropFirst 8L  // Drop "darkfs:/"
              |> Stdlib.String.dropLast 5L   // Drop ".dark"

            let pm = LanguageTools.PackageManager.pm ()

            // Try to find the entity in the package manager
            // First try as a type, then function, then constant
            let getContent =
              // Try to find as a type
              // CLEANUP: use `pm.findType nameForLookup` directly once the parser/interpreter is fixed
              let findType = pm.findType
              let getType = pm.getType
              match findType nameForLookup with
              | Some id ->
                match getType id with
                | Some typ -> typ |> PrettyPrinter.ProgramTypes.packageType
                | None -> "Could not get type"
              | None ->
                // Try to find as a function
                // CLEANUP: use `pm.findFn nameForLookup` directly once the parser/interpreter is fixed
                let findFn = pm.findFn
                let getFn = pm.getFn
                match findFn nameForLookup with
                | Some id ->
                  match getFn id with
                  | Some fn -> fn |> PrettyPrinter.ProgramTypes.packageFn
                  | None -> "Could not get function"
                | None ->
                  // Try to find as a constant
                  // CLEANUP: use `pm.findConstant nameForLookup` directly once the parser/interpreter is fixed
                  let findConst = pm.findConstant
                  let getConst = pm.getConstant
                  match findConst nameForLookup with
                  | Some id ->
                    match getConst id with
                    | Some constant ->
                      constant |> PrettyPrinter.ProgramTypes.packageConstant
                    | None -> "Could not get constant"
                  | None -> $"Package element not found: {nameForLookup}"

            sendResponse state requestId getContent


        module WriteFile =
          let handleWriteFileRequest
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (params:
              LspExtension.FileSystemProvider.WriteFile.WriteFileParams.WriteFileParams)
            : LspState =
            let content = params.content
            let responseJson =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some(requestId))
                (Json.String content))
              |> Stdlib.AltJson.format

            logAndSendToClient responseJson
            state