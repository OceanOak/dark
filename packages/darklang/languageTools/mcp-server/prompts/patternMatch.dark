/// Pattern matching helper prompt
module Darklang.LanguageTools.McpServer.Prompts.PatternMatch


/// Get the prompt description for pattern matching
let getPromptDescription () : ModelContextProtocol.PromptDescription =
  ModelContextProtocol.PromptDescription {
    name = "pattern_match"
    description = Stdlib.Option.Option.Some "Generate pattern matching code for a given type"
    arguments = Stdlib.Option.Option.Some [
      ModelContextProtocol.PromptArgument {
        name = "type_definition"
        description = Stdlib.Option.Option.Some "The type to match against"
        required = Stdlib.Option.Option.Some true
      };
      ModelContextProtocol.PromptArgument {
        name = "context"
        description = Stdlib.Option.Option.Some "Additional context about the use case"
        required = Stdlib.Option.Option.Some false
      }
    ]
  }

/// Generate the pattern matching prompt content
let generatePrompt (typeDefinition: String) (context: Stdlib.Option.Option<String>) : List<ModelContextProtocol.PromptMessage> =
  let contextText = 
    match context with
    | Some c -> $"\n\nAdditional context: {c}"
    | None -> ""

  let systemPrompt = "You are a Darklang pattern matching assistant. Generate comprehensive pattern matching code for the given type, covering all cases and providing idiomatic Darklang solutions."

  let userPrompt = $"Please generate pattern matching code for this Darklang type:\n\n```darklang\n{typeDefinition}\n```{contextText}\n\nPlease provide:\n1. A complete match expression covering all cases\n2. Example implementations for each case\n3. Common patterns and best practices\n4. Any important considerations for this type"

  [
    ModelContextProtocol.PromptMessage {
      role = ModelContextProtocol.MessageRole.System
      content = ModelContextProtocol.PromptContent.Text systemPrompt
    };
    ModelContextProtocol.PromptMessage {
      role = ModelContextProtocol.MessageRole.User  
      content = ModelContextProtocol.PromptContent.Text userPrompt
    }
  ]